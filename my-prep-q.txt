ğŸŒ SPRING / SPRING BOOT (Must for Backend Devs)
-------------------------------------------------------------
ğŸ”¹ Q1. Dependency inversion principle vs Dependency Injection
-------------------------------------------------------------
ğŸ”‘ Dependency Inversion Principle (DIP) is a design principle. 
	âœ”Part of SOLID principles.
	âœ”High-level modules should not depend on low-level modules. Both should depend on abstractions.
ğŸ”‘ Dependency Injection (DI) is a design pattern / technique to implement that principle.
	âœ”Provides dependencies from outside instead of creating them
	âœ”Achieve loose coupling, Enable DIP, Improve testability
	
-------------------------------------------------------------
ğŸ”¹ Q2. @Component vs @Service vs @Repository vs @RestController vs @Controller
-------------------------------------------------------------
All five are Spring stereotype annotations used for component scanning, 
but each represents a different layer and responsibility in a Spring application.
ğŸ”‘ @Component â€” Generic Spring Bean 
	âœ”What is it: Base stereotype annotation, Parent of all other stereotypes.
	âœ”When to use: Utility classes, Helpers, Shared components, When no specific layer fits
	
ğŸ”‘ @Service â€” Business Logic Layer
	âœ” What it is: Specialization of @Component, Represents service layer
	âœ” When to use: Business rules, Orchestration logic, Transaction boundaries
	âœ” Enables clean application of cross-cutting concerns

ğŸ”‘ @Repository â€” Persistence / DAO Layer (Special behavior Exception translation)
	âœ” What it is: Specialization of @Component, Represents data access layer
	âœ” Exception translation: Converts SQLException, HibernateException Into DataAccessException (unchecked)
	âœ” Using @Service instead of @Repository works, but you lose exception translation.
	
ğŸ”‘ @Controller â€” MVC Web Controller
	âœ” What it is: Specialization of @Component, Used in Spring MVC (server-side rendering)
	âœ” Default behavior: Returns view names, Used with JSP, Thymeleaf, etc., Needs @ResponseBody for REST

ğŸ”‘ @RestController â€” REST API Controller
	âœ” What it is: Combination of: @Controller + @ResponseBody
	âœ” When to use: REST APIs, Microservices, JSON / XML responses

-------------------------------------------------------------
ğŸ”¹ Q3. Explain spring Bean Lifecycle ?
-------------------------------------------------------------
ğŸ” What is the Spring Bean Lifecycle: It is the sequence of steps Spring follows to create,
   initialize, use, and destroy a bean inside the IoC container.
ğŸªœ Step-by-Step Lifecycle
1ï¸âƒ£ Bean Definition Loaded
	âœ” Spring reads configuration (XML / Java Config / Annotations).
	âœ” Creates BeanDefinition (scope, dependencies, init/destroy methods).

2ï¸âƒ£ Bean Instantiation: 
	âœ” Spring creates the bean instance using the constructor.
	âœ” Object exists, but dependencies are not injected yet.

3ï¸âƒ£ Dependency Injection (Populate Properties)
	âœ” Injects dependencies via: Constructor / Setter / Field (@Autowired)
	
4ï¸âƒ£ Aware Interfaces (Optional)
	âœ” If implemented, Spring injects container context: BeanNameAware, BeanFactoryAware, ApplicationContextAware
	
5ï¸âƒ£ BeanPostProcessor â€” Before Initialization [postProcessBeforeInitialization(bean, beanName)]
	âœ” Used for: Validation, Pre-init customization, Framework logic

6ï¸âƒ£ Initialization Phase (IMPORTANT) : Spring runs any/all of the following in order:
	âœ” a) @PostConstruct (Recommended)
	âœ” b) InitializingBean.afterPropertiesSet()
	âœ” c) Custom init-method : @Bean(initMethod = "customInit")

7ï¸âƒ£ BeanPostProcessor â€” After Initialization [postProcessAfterInitialization(bean, beanName)]
	âœ” AOP proxies (@Transactional, @Async) are created here.

8ï¸âƒ£ Bean is READY to Use ğŸ‰: 
	âœ” Fully initialized, Dependencies injected, Proxies applied (if any), Available from ApplicationContext

8ï¸âƒ£  Destruction Phase (Shutdown) 
	âœ” Triggered when: Application stops, Context is closed
	ğŸ§¹ Destruction callbacks (order):
		âœ” a) @PreDestroy
		âœ” b) DisposableBean.destroy()
		âœ” c) Custom destroy-method
âš ï¸ Called only for singleton beans
âš ï¸ Prototype beans are not destroyed by Spring

-------------------------------------------------------------
ğŸ”¹ Q4. How you will call the @Predestory marked methods in the standalone application.
-------------------------------------------------------------
ğŸ”‘ Key rule: @PreDestroy methods are called only when the Spring container is closed.
âœ” In a standalone (non-web) application, you must explicitly close the ApplicationContext.
	ğŸ§¹context.close(); 
	âœ… Using try-with-resources
	âœ… Alternative (Register shutdown hook): context.registerShutdownHook();
ğŸ”‘ Why @PreDestroy does NOT work for prototype scope:
	âœ…Spring manages the entire lifecycle of singleton beans, but only the creation phase of prototype beans.
ğŸ”‘ Then who should destroy prototype beans?
	ğŸ‘‰ Developer. TempBean bean = context.getBean(TempBean.class); bean.cleanup();
	ğŸ‘‰ Or implement AutoCloseable:
		public class TempBean implements AutoCloseable {
			@Override
			public void close() {
				// cleanup
			}
		}
ğŸ”‘ What happens in a Web Application?
	ğŸ‘‰ The Servlet container (Tomcat / Jetty / Undertow) controls the lifecycle.
	ğŸ‘‰ @PreDestroy methods are called automatically when the web application is shutting down.
âœ… Who triggers it internally?
	âœ”Classic Spring MVC (WAR) : ContextLoaderListener, Listens to servlet lifecycle, Calls contextDestroyed(), Closes Spring context
	âœ”Spring Boot: Embedded server, Spring Boot auto-registers shutdown hooks, Calls ApplicationContext.close()

-------------------------------------------------------------
ğŸ”¹ Q5. Explain the helper class that initializes and destroys the web application context.
-------------------------------------------------------------
ğŸ”‘ ContextLoaderListener is a Spring-provided ServletContext listener that bridges the servlet container lifecycle with the Spring IoC container.It initialize the root WebApplicationContext when the web app starts and destroy (close) the WebApplicationContext when the web app stops.

ğŸ”‘ Why is this helper class needed?: In a web application, the lifecycle is controlled by the Servlet container (Tomcat, Jetty, etc.), not by Spring. Spring needs a hook to Start the IoC container at application startup and Cleanly shut it down during application shutdown. â¡ï¸ ContextLoaderListener provides exactly this hook.

ğŸ”‘ What happens during Application Startup?
Web Container starts â†“ ServletContext initialized â†“ ContextLoaderListener.contextInitialized()
â†“ Spring creates Root WebApplicationContext â†“ Beans are instantiated & initialized

Internally: Reads contextConfigLocation, Creates the root application context, Stores it in ServletContext

ğŸ”‘ What happens during Application Shutdown?
Server stops / App undeployed â†“ ServletContext destroyed â†“ ContextLoaderListener.contextDestroyed() 
â†“ Spring closes ApplicationContext â†“ @PreDestroy / destroy() methods called

âœ” Proper cleanup, Resource release, Graceful shutdown

ğŸ”‘ Configuration (Classic Spring MVC â€“ WAR)
	web.xml
	<listener>
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/applicationContext.xml</param-value>
	</context-param>

ğŸ”‘ Root vs Servlet WebApplicationContext (IMPORTANT)
Spring web apps have two contexts: 
| Context                           | Created by              | Contains                            |
| --------------------------------- | ----------------------- | ----------------------------------- |
| **Root WebApplicationContext**    | `ContextLoaderListener` | Services, Repositories, DataSources |
| **Servlet WebApplicationContext** | `DispatcherServlet`     | Controllers, ViewResolvers          |


ğŸ”‘ Relationship with DispatcherServlet
	âœ” ContextLoaderListener â†’ initializes shared beans
	âœ” DispatcherServlet â†’ handles web layer only
	âœ” This separation: Improves modularity, Keeps web concerns isolated

ğŸ”‘ What about Spring Boot?
	âœ” You do not explicitly configure ContextLoaderListener
	âœ” Boot auto-configures it internally
	âœ” Lifecycle behavior remains the same

-------------------------------------------------------------
ğŸ”¹ Q5. What are all RestClients in spring?
-------------------------------------------------------------
ğŸ”‘ RestTemplate (Legacy â€“ synchronous)
	âœ” Where: Older Spring Boot (2.x) projects, Simple internal REST calls
	âœ” Why: Easy to use, Blocking & synchronous

ğŸ”‘ WebClient (Reactive & non-blocking)
	âœ” Where: Microservices, High-throughput systems, Parallel API calls
	âœ” Why: Non-blocking I/O, Better scalability, Supports reactive streams
	
ğŸ”‘ Spring RestClient (Spring 6+) â­ Preferred now
	âœ” Where: New Spring Boot 3 projects
	âœ” Why: Modern replacement for RestTemplate, Fluent, clean API, Still synchronous (easy to reason about)

ğŸ”‘ Feign Client (Declarative REST client)
	âœ” Where: Microservices (Spring Cloud), Service-to-service communication
	âœ” Why: Interface-based, Less boilerplate, Integrates well with load balancing & resilience
	
ğŸ”‘ Apache HttpClient (Low-level control)
	âœ” Where: Legacy systems, Custom SSL / proxy / timeout requirements
	âœ” Why: Full control over HTTP, Fine-grained configuration

-------------------------------------------------------------
ğŸ”¹ Q6. getForEntity() vs postForEntity()
-------------------------------------------------------------
| Aspect         | `getForEntity()` | `postForEntity()` |
| -------------- | ---------------- | ----------------- |
| HTTP Method    | GET              | POST              |
| Purpose        | Fetch data       | Create/send data  |
| Request Body   | âŒ No            | âœ… Yes           |
| Idempotent     | âœ… Yes           | âŒ No            |
| Cacheable      | âœ… Yes           | âŒ No            |
| Typical Status | 200 OK           | 201 Created       |
| Use case       | Read operations  | Create operations |

-------------------------------------------------------------
ğŸ”¹ Q7. What are the uses of ResponseEntity?
-------------------------------------------------------------
ResponseEntity<T> represents the entire HTTP response â€” status code, headers, and body.
1ï¸âƒ£ Control HTTP Status Codes : âœ… return ResponseEntity.status(HttpStatus.CREATED).body(user);
	âœ” Instead of always returning 200 OK, you can return meaningful REST status codes.
2ï¸âƒ£ Add / Modify HTTP Headers : âœ… return new ResponseEntity<>(user, headers, HttpStatus.OK);
	âœ” Used for: Authentication tokens, Location header, Caching, CORS, Custom metadata
3ï¸âƒ£ Return Response Body Conditionally
4ï¸âƒ£ Build RESTful Responses (Best Practice)
5ï¸âƒ£ Support Content Negotiation : âœ… return ResponseEntity.ok().contentType(MediaType.APPLICATION_JSON)body(user);
	âœ” ResponseEntity works with: Accept header, Message converters
6ï¸âƒ£ Handle Empty Responses Properly
7ï¸âƒ£ Centralized Error Handling Integration
8ï¸âƒ£ Generic & Type-safe Responses
9ï¸âƒ£ Avoid Using void or Raw Objects âŒ

-------------------------------------------------------------
ğŸ”¹ Q7. Why should you handle response timeout while calling any API?
-------------------------------------------------------------
ğŸ”‘ We handle response timeouts to avoid thread blocking, prevent cascading failures,
 protect system resources, and maintain predictable latency and SLAs.
1ï¸âƒ£ Prevent thread blocking & resource exhaustion
	âœ” Without a timeout, a client thread can wait forever.
	âœ” Under load, blocked threads exhaust pools â†’ system slowdown or crash.
	âœ” Timeout = fail fast and free resources.
	
2ï¸âƒ£ Avoid cascading failures
	âœ” One slow/downstream service can stall callers.
	âœ” Without timeouts, failures propagate across services.
	âœ” Timeouts isolate failures and keep the rest of the system responsive.

3ï¸âƒ£ Maintain predictable latency & SLAs
	âœ” APIs must respond within defined SLAs (e.g., 300â€“500 ms).
	âœ” Timeouts enforce upper bounds on waiting, keeping latency predictable.

4ï¸âƒ£ Enable resilience patterns
	âœ” Timeouts are prerequisites for:Retries, Circuit breakers, Fallbacks, Bulkheads
	âœ” No timeout â†’ these patterns canâ€™t trigger effectively.

5ï¸âƒ£ Protect against unreliable external dependencies
	âœ” Third-party APIs can hang, slow down, or partially fail.
	âœ” Timeouts protect your system from vendor/network issues.

6ï¸âƒ£ Improve user experience
	âœ” Users prefer quick failure with a clear error over infinite loading.
	âœ” Enables graceful degradation (cached data, partial responses).

7ï¸âƒ£ Security & abuse protection
	âœ” Prevents slow-response attacks (e.g., keeping connections open).
	âœ” Limits how long a malicious or buggy endpoint can tie up resources.

-------------------------------------------------------------
ğŸ”¹ Q8. Explain the differences between Server timeout and Read timeout.
-------------------------------------------------------------
ğŸ”‘ Server timeout limits how long the server is allowed to process a request,
while Read timeout limits how long the client waits to receive a response after sending the request.
1ï¸âƒ£ Server Timeout (Server-side)
	âœ” What: 
		ğŸ”¹Configured on the server / gateway / load balancer
		ğŸ”¹Maximum time allowed for request processing
		ğŸ”¹Includes business logic, DB calls, downstream calls
	âœ” What happens when it expires: Server stops processing, Returns an error response
	âœ” Common responses: 504 Gateway Timeout, 503 Service Unavailable, 500 Internal Server Error (implementation-specific)
	âœ” Typical places configured: API Gateway (Nginx, Kong), Load balancer, Application server (Tomcat, Undertow)

2ï¸âƒ£ Read Timeout (Client-side)
	âœ”	What:
		ğŸ”¹Configured on the client
		ğŸ”¹Maximum time client waits for response data
		ğŸ”¹Starts after request is sent and connection is established
	âœ”	What happens when it expires: Client throws a timeout exception, Connection is closed by the client
	âœ”	Common exceptions: SocketTimeoutException, ReadTimeoutException, WebClientRequestException

Case 1: Read timeout < Server timeout => Client times out first, Server may still process request (wasted work)
Case 2: Server timeout < Read timeout => Server fails fast, Client receives error response
ğŸ‘‰ Best practice: Server timeout â‰¤ Client read timeout

-------------------------------------------------------------
ğŸ”¹ Q9. What is versioning in Rest? what are the ways that you can use to implement versioning? 
-------------------------------------------------------------
ğŸ”‘ REST API versioning is the practice of managing breaking changes to an API so that existing clients continue to work while newer clients adopt updated behavior.
	ğŸ”¹Why:
		âœ” Clients depend on a stable contract
		âœ” Mobile apps canâ€™t upgrade instantly
		âœ” Third-party integrations must not break
		âœ” APIs evolve over time (fields change, behavior changes)

1ï¸âƒ£ URI (Path) Versioning â­ Most Common : GET /api/v2/users
2ï¸âƒ£ Query Parameter Versioning : GET /api/users?version=1
3ï¸âƒ£ Header Versioning (Custom Header): @GetMapping(value = "/users", headers = "X-API-VERSION=1")
4ï¸âƒ£ Media Type Versioning (Content Negotiation) â­ Most RESTful :
	@GetMapping(
	  value = "/users",
	  produces = "application/vnd.company.users-v1+json"
	)

-------------------------------------------------------------
ğŸ”¹ Q10. How does Basic Authentication work in Rest API?
-------------------------------------------------------------
ğŸ”‘ Basic Authentication is an HTTP authentication scheme where the client sends username and password (Base64-encoded) with every request via the Authorization header.
1ï¸âƒ£ Client requests a protected resources : GET /api/users
2ï¸âƒ£ Server challenges the client
	âœ” If no credentials are sent: 401 Unauthorized WWW-Authenticate: Basic realm="users"

3ï¸âƒ£ Client sends credentials: 
	âœ” Combines username:password, Encodes with Base64, Sends in header
	âœ” Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ= (username:password â†’ Base64)

4ï¸âƒ£ Server validates credentials
	âœ” Decodes Base64, Extracts username & password, Validates against DB / LDAP / IdP
5ï¸âƒ£ Server responds
	âœ… 200 OK â†’ valid credentials
	âŒ 401 Unauthorized â†’ invalid credentials

-------------------------------------------------------------
ğŸ”¹ Q11. Should you use JWT or Session-based authentication in the microservices environment? 
-------------------------------------------------------------
	| Aspect               | Session-based | JWT         |
	| -------------------- | ------------- | ----------- |
	| State                | Stateful      | Stateless   |
	| Scalability          | âŒ Poor      | âœ… Excellent|
	| Microservices fit    | âŒ No        | âœ… Yes      |
	| Cross-service calls  | Hard          | Easy        |
	| Infrastructure       | Session store | None        |
	| Cloud / K8s friendly | âŒ            | âœ…         |
	| Architecture         | Monolithic    | Microservice|

-------------------------------------------------------------
ğŸ”¹ Q12. What is content negotiation?
-------------------------------------------------------------
ğŸ”‘ Content negotiation allows a REST API to return different representations of the 
   same resource based on the clientâ€™s Accept header.
Why Content Negotiation is needed
	âœ” Different clients prefer different formats
	  ğŸ”¹Browsers â†’ HTML
	  ğŸ”¹Mobile apps â†’ JSON
	  ğŸ”¹Legacy systems â†’ XML
	âœ” One API serves multiple consumers
	âœ” Keeps URIs stable and resource-oriented

-------------------------------------------------------------
ğŸ”¹ Q13. What are the cross-cutting concerns in spring? how do you implement it in microservices architecture?
-------------------------------------------------------------
ğŸ”‘ Cross-cutting concerns are functionalities that span across multiple layers and modules
   of an application but are not part of core business logic.
	| Concern              | What it does                        |
	| -------------------- | ----------------------------------- |
	| Logging              | Method entry/exit, request/response |
	| Security             | Authentication & authorization      |
	| Transactions         | Commit / rollback management        |
	| Exception Handling   | Centralized error handling          |
	| Caching              | Performance optimization            |
	| Validation           | Input & business validation         |
	| Monitoring & Metrics | Health, performance                 |
	| Distributed Tracing  | Trace & correlation IDs             |
	| Auditing             | Who changed what & when             |
	| Rate Limiting        | Prevent abuse                       |

â“ Why handle them separately?
	âœ” Without separation: Code duplication, Tangled business logic, Hard maintenance, Inconsistent behavior
	âœ” Spring provides infrastructure mechanisms to keep business code clean.
	
1ï¸âƒ£ How Spring Implements Cross-Cutting Concerns (Core Concepts)
	ğŸ”¹A. Spring AOP â­â­â­â­â­: 	âœ” No code duplication, âœ” Applied uniformly
	ğŸ”¹B. Declarative Annotations: @Transactional, @Cacheable, @Async, @Secured

2ï¸âƒ£ Cross-Cutting Concerns in Microservices Architecture
ğŸ”¹API Gateway Level (Global): Tools => Spring Cloud Gateway, Nginx, Kong, AWS API Gateway
	| Concern         | How                     |
	| --------------- | ----------------------- |
	| Authentication  | OAuth2 / JWT validation |
	| Rate limiting   | Gateway filters         |
	| CORS            | Gateway configuration   |
	| Request logging | Global filters          |

ğŸ”¹Service Level (Spring AOP)
	| Concern            | Mechanism           |
	| ------------------ | ------------------- |
	| Transactions       | `@Transactional`    |
	| Logging            | AOP aspects         |
	| Validation         | Bean Validation     |
	| Caching            | `@Cacheable`        |
	| Exception handling | `@ControllerAdvice` |

ğŸ”¹Filter & Interceptor Level
	| Tool                | Use                       |
	| ------------------- | ------------------------- |
	| Servlet Filters     | Security, correlation IDs |
	| HandlerInterceptors | Request metadata          |
	| WebClient Filters   | Outgoing calls            |

ğŸ”¹Distributed Tracing (Microservices-specific): Tools => OpenTelemetry, Zipkin, Jaeger
	âœ” Correlation ID propagation, Trace ID / Span ID

ğŸ”¹Centralized Observability
	| Concern | Tool            |
	| ------- | --------------- |
	| Logs    | ELK / EFK       |
	| Metrics | Prometheus      |
	| Traces  | Jaeger / Zipkin |




-------------------------------------------------------------
ğŸ”¹ Q14. How to create custom validators in spring?
-------------------------------------------------------------
ğŸ”‘ A custom validator allows you to define your own validation rules beyond
   standard constraints (@NotNull, @Size, etc.) using Bean Validation (Jakarta Validation / JSR-380).
  
âœ… Recommended Way: Annotation-based Bean Validation
Step 1ï¸âƒ£ Create a Custom Constraint Annotation
	@Documented
	@Constraint(validatedBy = PasswordStrengthValidator.class)
	@Target({ ElementType.FIELD, ElementType.PARAMETER })
	@Retention(RetentionPolicy.RUNTIME)
	public @interface StrongPassword {
		String message() default "Password is too weak";
		Class<?>[] groups() default {};
		Class<? extends Payload>[] payload() default {};
	}
	
Step 2ï¸âƒ£ Implement ConstraintValidator
	public class PasswordStrengthValidator implements ConstraintValidator<StrongPassword, String> {

		@Override
		public boolean isValid(String value, ConstraintValidatorContext context) {
			if (value == null) return false;
			return value.length() >= 8 &&
				   value.matches(".*[A-Z].*") &&
				   value.matches(".*[0-9].*");
		}
	}

Step 3ï¸âƒ£ Use the Custom Validator
	public class UserRequest {

		@StrongPassword
		private String password;
	}

-------------------------------------------------------------
ğŸ”¹ Q15. How spring's singleton scope is different then GOF signleton?
-------------------------------------------------------------
1ï¸âƒ£ Spring Singleton Scope
	âœ” What: One bean instance per ApplicationContext, Managed by Spring container, Default scope in Spring
	âœ” Lifecycle is fully managed by Spring @PostConstruct/@PreDestroy, Easy to test and mock
	âœ” Clean DI, Loose coupling, Works with AOP, transactions, proxies

2ï¸âƒ£ GoF Singleton Pattern
	âœ” What: One instance per JVM, Enforced by code, No framework involved
	âœ” JVM-wide single instance, Global access, No lifecycle hooks
	âŒ Hard to test, Global state, Tight coupling, Thread-safety complexity, Cannot easily reset between tests

-------------------------------------------------------------
ğŸ”¹ Q16. Tell me some Spring Exceptions that you came across with example ?
-------------------------------------------------------------
1ï¸âƒ£ NoSuchBeanDefinitionException
	âœ” Why: Spring cannot find a required bean, Wrong package scanning, Missing implementation for an interface

2ï¸âƒ£ BeanCreationException
	âœ” Why: Bean fails during creation, Exception inside constructor or @PostConstruct

3ï¸âƒ£ UnsatisfiedDependencyException
	âœ” Why: Dependency chain cannot be resolved, Constructor injection failure, Circular dependency
	
4ï¸âƒ£ HttpRequestMethodNotSupportedException
	âœ” Why: Client uses wrong HTTP method, Endpoint mapping mismatch

5ï¸âƒ£ MethodArgumentNotValidException
	âœ” Occurs when validation fails. public void create(@Valid @RequestBody User user) {}

6ï¸âƒ£ TransactionRequiredException
	âœ” Why: Executing update/delete query without transaction

7ï¸âƒ£ InvalidDataAccessApiUsageException
	âœ” Why: Wrong JPA usage, Passing null or invalid arguments

8ï¸âƒ£ DataIntegrityViolationException
	âœ” Why: DB constraint violation, Unique key, Foreign key, Not null constraint

9ï¸âƒ£ OptimisticLockingFailureException
	âœ” Why: Concurrent update with @Version

ğŸ”Ÿ NoUniqueBeanDefinitionException
	âœ” why: Interface with multiple implementations
	âœ” Spring resolves dependencies in this order: By type, By name, By qualifier, By @Primary
		âœ… Option 1: @Primary (Most common)
		âœ… Option 2: @Qualifier (Best practice for clarity)
		âœ… Option 3: Inject by name: private PaymentService cardPaymentService;
		âœ… Option 4: Inject all implementations: private List<PaymentService> paymentServices; 


-------------------------------------------------------------
ğŸ”¹ Q17. Tell me 10 spring Annotations that you have used ? (Excluding the stereotype annotations)
-------------------------------------------------------------
1ï¸âƒ£ @Autowired: Purpose: Inject dependencies automatically.
2ï¸âƒ£ @Qualifier: Purpose: Resolve ambiguity when multiple beans of same type exist.
3ï¸âƒ£ @Primary: Purpose: Marks a bean as default choice.
4ï¸âƒ£ @Value: Purpose: Inject values from properties or environment.
5ï¸âƒ£ @Configuration: Purpose: Marks a class as Spring Java configuration.
6ï¸âƒ£ @Bean: Purpose: Manually register a bean.
7ï¸âƒ£ @Transactional: Purpose: Manage database transactions declaratively.
8ï¸âƒ£ @RequestMapping: Purpose: Map HTTP requests to controller methods.
9ï¸âƒ£ @RequestBody: Purpose: Bind HTTP request body to Java object.
ğŸ”Ÿ @PathVariable: Purpose: Extract values from URI path.
ğŸ¯ Bonus (Very commonly used â€“ if interviewer asks more)
@RequestParam, @ResponseStatus, @ExceptionHandler, @ControllerAdvice
@PostConstruct, @PreDestroy, @EnableCaching, @Cacheable, @Validated, @Profile

-------------------------------------------------------------
ğŸ”¹ Q18. Is it required to write @Repository annotations in spring data JPA?
-------------------------------------------------------------
ğŸ”‘ No, it is not required to explicitly write @Repository on Spring Data JPA repository interfaces.
	Spring Data JPA:
		âœ” Automatically detects the interface
		âœ” Creates a proxy implementation at runtime
		âœ” Registers it as a Spring bean
		âœ” Marks it internally as @Repository
		âœ” So exception translation and bean registration are already handled.
		âœ” Convert PersistenceException, SQLException into Springâ€™s DataAccessException

-------------------------------------------------------------
ğŸ”¹ Q19. Explain the Spring Data Project and the hierarchy ? 
-------------------------------------------------------------
ğŸŒ³ Repository Hierarchy (Most Important for Interviews)
Repository (marker interface) : Enables Spring Data repository detection, âœ” Base for all repositories
   â†“
CrudRepository : âœ” Store-independent, âœ” Works for SQL & NoSQL
   â†“
PagingAndSortingRepository: âœ” Pagination, âœ” Sorting
   â†“
JpaRepository (JPA-specific) : âœ” Hibernate/JPA optimizations, âœ” Batch operations, âœ” Most common in real projects

ğŸ”— How Spring Data works internally (Simplified)
Repository Interface
        â†“
Spring Data Proxy
        â†“
EntityManager / Template
        â†“
Database

No implementation written by developer, Proxy created at runtime, Queries derived from method names

-------------------------------------------------------------
ğŸ”¹ Q20. Use of  @NoRepositoryBean in spring boot ?
-------------------------------------------------------------
ğŸ”‘ @NoRepositoryBean is a Spring Data annotation used to tell Spring: â€œDo NOT create a repository bean for this interface.â€
	It is mainly used for base (parent) repository interfaces that are meant to be extended, not instantiated.
	By default, Spring Data tries to create a bean for every repository interface it finds. If you create a generic/base repository interface, Spring will: Try to create a proxy bean for it and Fail at startup (because it has no domain type) @NoRepositoryBean prevents this.
	âœ” Spring Data itself uses @NoRepositoryBean on: Repository, CrudRepository, PagingAndSortingRepository
	ğŸ‘‰ Thatâ€™s why Spring doesnâ€™t try to create beans for them

-------------------------------------------------------------
ğŸ”¹ Q21. Different types of bean scope presenet in spring and its use case ?
-------------------------------------------------------------
ğŸ”‘ What is a Bean Scope in Spring: A bean scope defines how many instances of a bean Spring creates
   and how long that instance lives within the container.
   
   1ï¸âƒ£ singleton (Default & Most Used): One bean instance per Spring ApplicationContext, Shared across the entire application
   2ï¸âƒ£ prototype: New instance every time getBean() is called, Spring manages creation only, not destruction.
		@Component
		@Scope("prototype")
		public class ReportGenerator {}

   3ï¸âƒ£ request (Web Scope): One bean per HTTP request, Exists only during a single request
		@Component
		@Scope(value = WebApplicationContext.SCOPE_REQUEST)
		public class RequestContext {}

	4ï¸âƒ£ session (Web Scope): One bean per HTTP session, Shared across multiple requests of the same user
		@Component
		@Scope(value = WebApplicationContext.SCOPE_SESSION)
		public class UserSession {}
	
	5ï¸âƒ£ application (Web Scope): One bean per ServletContext, Similar to singleton, but web-specific
		@Component
		@Scope(value = WebApplicationContext.SCOPE_APPLICATION)
		public class AppMetadata {}

	6ï¸âƒ£ websocket (Specialized Web Scope): One bean per WebSocket session
		@Scope("websocket")
		@Component
		public class WebSocketSessionBean {}

   
   
-------------------------------------------------------------
ğŸ”¹ Q22. What is limitations of java config file?
-------------------------------------------------------------
1ï¸âƒ£ Tight Coupling Between Configuration & Code
	What: Configuration is written in Java
	Any config change requires: Code change, Recompile, Redeploy, 
	Example
		@Bean
		public DataSource dataSource() {
			return new HikariDataSource();
		}

		â¡ï¸ Changing pool type = code change

	Why itâ€™s a limitation: Ops/DevOps cannot change config easily, Not ideal for runtime-only configuration

2ï¸âƒ£ Less Runtime Flexibility Compared to XML / Properties
	XML / properties allow
	datasource.pool.size=20

	Java config requires
	dataSource.setMaximumPoolSize(20);

	â¡ï¸ Harder to externalize complex configurations

3ï¸âƒ£ Harder for Non-Java Users
	XML / YAML can be edited by: Ops, Support teams, 
	Java config requires: Java knowledge, IDE, Build process, ğŸ‘‰ Not business-friendly

4ï¸âƒ£ Verbosity for Large Configurations 
	Example: Large security / integration config
	Java config: Long, Hard to scan visually, Mixed with logic
	XML/YAML: More declarative, Easier to review

5ï¸âƒ£ Harder to Enable/Disable Config Dynamically
	Java config: Conditional logic must be coded
	@ConditionalOnProperty(name = "feature.enabled", havingValue = "true")
	Compared to XML
	<beans profile="prod">
ğŸ‘‰ XML / profiles can feel simpler for environment-based switching

6ï¸âƒ£ Accidental Business Logic in Configuration 
	Java config is Turing complete.
		@Bean
		public ObjectMapper mapper() {
			if (env.acceptsProfiles("prod")) {
				return prodMapper();
			}
			return devMapper();
		}
	âš ï¸ Risk: Logic-heavy config, Hard to test, Violates separation of concerns

7ï¸âƒ£ Startup Time Slightly Higher (Edge Case)
	Java config: Class loading, Reflection
	XML: Simple parsing
	ğŸ“Œ Usually negligible, but relevant in very large apps

8ï¸âƒ£ Not Ideal for Pure Configuration Data
	Example: Feature flags, Routing rules, Large static mappings
	Better stored in: YAML / properties, External config servers, Databases
	
	
-------------------------------------------------------------
ğŸ”¹ Q23. How a CGLIB Proxy works with @Bean?
-------------------------------------------------------------
-------------------------------------------------------------
@Component vs @Bean . What is the difference between creating a bean with @Bean and creating a bean with @Component ? 
What is a BeanFactoryPostProcessor?
Bean Factory Post Processor Code walkthrough
What do you mean by a @Transactional Annotation and explain the Transactional Propagation in spring? 
Transactional Propagation Explained ! 
application.properties vs application.yaml , Which will load first ?
How the dispatcher servlet is set up in a spring boot project?
how the dispatcher servlet in spring boot gets auto-configured?
How will you handle exceptions in spring?
Explain the need of a global exception handler in spring boot ?
Difference between @ControllerAdvice and @RestControllerAdvice?
How will you handle a Bad gateway exception when thrown from a rest client ?
Spring SecurityContext scope explained !
@Controller Vs @RestController
How a spring boot application bootstraps ?
REST API Best practices
Monolithic Architecture Vs Microservices Architecture
How to manage ipâ€™s and servers in a microservices architecture
How Service Discovery and Registration works ? ( A problem Scenario )
How Client side load balancing different then the Server Side load balancing ?
Is server side load balancing causes a single point of failure?
How to handle failure in a microservices environment ?
How the retry pattern works ?
How a block thread causes issue in a microservices environment ?
How to protect your microservices from random load?
Circuit Breaker design pattern - Quick KT
Explain the Half open state of a  circuit breaker in spring boot
How to track a slower Microservice which causes performance issue?
How to track exceptions in a microservices environment ?
How did you handle security in your Spring boot based application ?
What are the differences between SOAP and REST Webservices?
What is Spring Boot Actuator ?
How did you optimize your application ?
Explain API Gateway responsibilities in microservices architecture.
Explain how microservices communicate in your project â€” sync vs async, message brokers, retry mechanisms.
How do you secure REST APIs without using Spring Security? (Filters, interceptors, gateway rules, custom tokens, etc.)
Without Spring Security, I secure REST APIs using custom filters or interceptors for authentication, typically with JWT or API keys. Authorization is enforced manually using roles from tokens, combined with HTTPS, rate limiting, and infrastructure-level security.
Custom Servlet Filter
Register Filter
API Key Authentication

Explain internal working of REST Template & WebClient and which one you prefer.
ğŸ”¹ Step-by-Step Execution Flow
1ï¸âƒ£ Your code calls:
restTemplate.getForObject(url, Response.class);
2ï¸âƒ£ RestTemplate: Creates a ClientHttpRequest, Serializes request body using HttpMessageConverters
3ï¸âƒ£ ClientHttpRequestFactory: Uses underlying HTTP client:
SimpleClientHttpRequestFactory â†’ JDK HttpURLConnection
HttpComponentsClientHttpRequestFactory â†’ Apache HttpClient
4ï¸âƒ£ Thread blocks until: Response is received, Response body is deserialized
5ï¸âƒ£ Control returns to calling thread

ğŸ”¹ Step-by-Step Execution Flow
1ï¸âƒ£ Your code calls:
webClient.get()
    .uri(url)
    .retrieve()
    .bodyToMono(Response.class);

2ï¸âƒ£ WebClient:Builds request using fluent API, Does NOT block the thread
3ï¸âƒ£ Request handled by Reactor Netty: Uses event-loop threads, No thread per request
4ï¸âƒ£ Response arrives: Callback (Mono / Flux) is triggered, Data flows downstream
5ï¸âƒ£ Thread is released immediately after request initiation

How does Circuit Breaker work? Explain with Resilience4j/Spring Cloud example.
What happens inside JVM when a thread is created?
When a thread is created, 
JVM creates a Java Thread object, 
start() -> requests the OS to create a native thread,
allocates a thread stack and PC register(RUNNABLE), and hands execution to the OS scheduler, which eventually executes the run() method.

How will you design rate-limiting for an API?
ğŸ”¹ 1. Fixed Window: How it works: Count requests in a fixed time window
ğŸ”¹ 2. Sliding Window (Improved Fixed Window): Tracks requests more accurately using timestamps.

Explain @Transactional â€” how it works internally and rollback rules.
@Transactional works via Spring AOP proxies. It starts a transaction before method execution and commits or rolls back afterward. By default, it rolls back only on unchecked exceptions, but this can be customized using rollbackFor.

27. What is batch size in SQL ?
Batch size defines how many records are processed in one database call.
It reduces round trips to the database and improves performance during bulk operations.
Q9. What is Monolithic Architecture?
Ans:
A monolithic application is built as a single, unified unit. All the componentsâ€”like UI, business logic, data access layerâ€”are combined and run as a single application.
Example:A large e-commerce application where all features like product catalog, user management, payment, and order processing are tightly integrated and deployed together in one WAR/JAR file.

Q10. What is Microservices Architecture?
Ans:
A microservices architecture structures an application as a collection of small, loosely coupled services, each responsible for a specific business function and running independently.
Each service:
Has its own codebase
Can use a different technology stack
Communicates via APIs (REST, gRPC, messaging)
Can be developed, deployed, and scaled independently
Example:An e-commerce system with:
User-Service
Product-Service
Payment-Service
Order-Service â€” each deployed separately and communicating via REST APIs or events.

Q12. What is a Circuit Breaker? Why do we use it in microservices? 
Ans: A Circuit Breaker is a design pattern used in microservices architecture to prevent repeated failures in a distributed system by gracefully handling service outages.


Why do we use it in microservice?Microservices are distributed systems that talk to each other over a network. If Service A depends on Service B, and Service B is down or slow, Service Aâ€™s performance will degrade too â€” possibly leading to a cascade failure across the system.

Q13. How do you ensure fault tolerance in microservices? 
Ans:
Ensuring fault tolerance in microservices means designing your system so that it continues to function properly even if some of its components fail. In distributed systems, failures are inevitable â€” network issues, service crashes, timeouts, etc. Fault-tolerant microservices absorb these failures and fail gracefully instead of bringing the entire system down.
Key Concepts to Ensure Fault Tolerance in Microservices
Circuit Breaker Pattern
Retry Mechanism
Timeouts
Fallback Methods
Bulkhead Pattern
Load Balancing
Service Discovery and Self-Healing
Health Checks
Asynchronous Communication
Graceful Degradation

java
------------------------
How hashmap works internally?
List vs Set
java interview questions coding
ArrayList Internal coding hands-on questions 
Collection coding interview questions java
defining the constructor capacity in Arraylist increases performance?
How Arraylist works internally?
Difference between fail fast/fail safe collections 
Which types of collections consume more memory; fail-fast or fail-safe?
core java coding questions in collection iterator.
Can you modify the collection return by Arrays.asList()?
Questions on ConcurrentModificationException and CopyOnWriteArrayList.
What is a Marker interface in java ?
CompileTime Vs RunTime Exceptions . Checked vs Unchecked Exceptions in Java 
How to create custom Java Exceptions?
What is ThreadLocal in Java? Tell me a real time scenario if you have used it ever.
what is solid principles in java ?
single responsibility principle
what is string constant pool in java ?
string object creation interview questions
hashmap internal working
why multiple inheritance is not supported in java
java interface interview questions
java 8 function vs bifunction
method hiding in java vs method Overriding
@Override retention policy 
what is memory leak in java ?
How do you protect your code from memory leak ?
what is try with resources in java ?
how thread communication happens in java ?
what is serialization in java ?
Can you please provide real world example of OOPS Concepts ?
Are Singleton classes threa-safe in Java?
How to create a immutable class in Java ?
What is Parallel stream in Java?
How to debug high CPU usage in a Java application in production?
What happens if two threads try to update the same record? (Race condition, pessimistic/optimistic locking)
Difference between CompletableFuture & Parallel Streams and which one is better.
How does garbage collection work in Java 11?
Difference between HashMap, ConcurrentHashMap, SynchronizedMap and real-time scenarios where you used them.
| Feature     | HashMap   | SynchronizedMap    | ConcurrentHashMap |
| ----------- | --------- | ------------------ | ----------------- |
| Thread-safe | âŒ       | âœ…                  | âœ…               |
| Locking     | None      | Entire map         | Bucket-level      |
| Performance | High      | Low                | High              |
| Null key    | âœ…        | âœ…                | âŒ                 |
| Null value  | âœ…        | âœ…                | âŒ                 |
| Iteration   | Fail-fast | Must sync manually | Weakly consistent |

Q1. What are the main features introduced in Java 8 ?
Ans:
1.Lambda Expressions
2. Functional Interfaces
3. Stream API
4. Default and Static methods in Interfaces
5. java.time API (Date and Time)
6. Optional class
7. CompletableFuture and Parallel Streams
8. Method references

Q2. What is a Lambda Expression?
Ans:
lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are used primarily to define the implementation of a functional interface (an interface with only one abstract method).Syntax of Lambda Expression:(parameters) -expressionor(parameters) - {
    // statements
    return value;
}

Q3. Why Lambda Expressions Were Introduced?
Ans:
Lambda expressions were introduced to:
 Simplify code by enabling functional programming features
 Removing boilerplate
 Improving readability
Providing a better way to work with functional interfaces and collections.

Q4. What is a Functional Interface?
Ans:
An interface with exactly one abstract method.Examples: Runnable, Callable, Comparator, Function, Predicate, etc.
You can use @FunctionalInterface annotation for clarity.

Benefit
Explanation
Enables lambda expressions
Foundation for functional programming in Java
Simplifies code
Less boilerplate (no anonymous inner classes)
Stream API integration
Used with map, filter, forEach, etc.
Enables behavior as data
You can pass behavior (methods) as parameters
Works with built-in interfaces
Like Function, Predicate, etc.

Q5. What is difference between map and flatMap?
Ans:
 The map() method in Java Stream API is used to transform each element of a stream into another object, applying a function to each element in the stream.Purpose of map():
Used to transform or convert data.
Does not modify the original stream but creates a new stream.
The flatMap() method is used to transform and flatten complex or nested data structuresâ€”especially when each element of a stream contains a collection (e.g., List, Set, Stream).Purpose of flatMap:
Use flatMap() when each element in the original stream needs to be converted to a stream, and then flattened into a single stream.


Hibernate
----------------------
Difference between Hibernate and Jdbc (hibernate vs JDBC)
Session VS Session factory (Differences)
Can you create multiple session factory objects? Justify your answer!
What is the equivalent object of the session in JPA?
What is persistence context in JPA / Hibernate?
Explain the first level of caching in Hibernate.
Justify the difference between get() and load() in Hibernate.
get method Vs load method [Coding Challenge]
Explain the transient state in JPA/ Hibernate.
What is a detached state in hibernate? 
How to detach an entity object from the persistence state without closing the session?
Coding challenge on Hibernate states.
Why do we need a connection pool? 
How will you implement connection pooling in your project?
What are the fetch types available in hibernate? Explain how will you use it in real-time.
Eagar Vs Lazy code practice 
What is a @Generated value annotation? Explain the different generation types available in JPA / hibernate.
Code Practice [Auto Vs Identity Vs Table generation type]
Explain the advantages of Named queries in hibernate/JPA? 
What is Criteria API in Hiberante? Explain the advantages.
@NamedQuery/@NamedQueries quick KT
Criteria API In Hibernate quick KT[Query/Restrictions /Pagination/Filter demo]
Update vs Merge | Difference between update and merge method in JPA / Hibernate?
Entity Object Vs Value Object - When to use what ?
What is an one to one mapping and how to set up it with JPA/Hibernate ?


 


