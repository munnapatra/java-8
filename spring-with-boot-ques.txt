ğŸŒ SPRING / SPRING BOOT (Must for Backend Devs)
-------------------------------------------------------------
ğŸ”¹ Q1. Dependency inversion principle vs Dependency Injection
-------------------------------------------------------------
ğŸ”‘ Dependency Inversion Principle (DIP) is a design principle. 
	âœ”Part of SOLID principles.
	âœ”High-level modules should not depend on low-level modules. Both should depend on abstractions.
ğŸ”‘ Dependency Injection (DI) is a design pattern / technique to implement that principle.
	âœ”Provides dependencies from outside instead of creating them
	âœ”Achieve loose coupling, Enable DIP, Improve testability
	
-------------------------------------------------------------
ğŸ”¹ Q2. @Component vs @Service vs @Repository vs @RestController vs @Controller
-------------------------------------------------------------
All five are Spring stereotype annotations used for component scanning, 
but each represents a different layer and responsibility in a Spring application.
ğŸ”‘ @Component â€” Generic Spring Bean 
	âœ”What is it: Base stereotype annotation, Parent of all other stereotypes.
	âœ”When to use: Utility classes, Helpers, Shared components, When no specific layer fits
	
ğŸ”‘ @Service â€” Business Logic Layer
	âœ” What it is: Specialization of @Component, Represents service layer
	âœ” When to use: Business rules, Orchestration logic, Transaction boundaries
	âœ” Enables clean application of cross-cutting concerns

ğŸ”‘ @Repository â€” Persistence / DAO Layer (Special behavior Exception translation)
	âœ” What it is: Specialization of @Component, Represents data access layer
	âœ” Exception translation: Converts SQLException, HibernateException Into DataAccessException (unchecked)
	âœ” Using @Service instead of @Repository works, but you lose exception translation.
	
ğŸ”‘ @Controller â€” MVC Web Controller
	âœ” What it is: Specialization of @Component, Used in Spring MVC (server-side rendering), Methods typically return view names
	âœ” When to use: Building MVC apps, Rendering HTML, Using JSP / Thymeleaf
	âœ” Default behavior: Returns view names, Used with JSP, Thymeleaf, etc., Needs @ResponseBody for REST
	âœ” Key points: Uses ViewResolver, Needs @ResponseBody to return JSON

ğŸ”‘ @RestController â€” REST API Controller
	âœ” What it is: Combination of: @Controller + @ResponseBody
	âœ” When to use: REST APIs, Microservices, JSON / XML responses
	âœ” Key points: Returns JSON/XML by default, Uses HttpMessageConverter, No ViewResolver involved

-------------------------------------------------------------
ğŸ”¹ Q3. Explain spring Bean Lifecycle ?
-------------------------------------------------------------
ğŸ” What is the Spring Bean Lifecycle: It is the sequence of steps Spring follows to create,
   initialize, use, and destroy a bean inside the IoC container.
ğŸªœ Step-by-Step Lifecycle
1ï¸âƒ£ Bean Definition Loaded
	âœ” Spring reads configuration (XML / Java Config / Annotations).
	âœ” Creates BeanDefinition (scope, dependencies, init/destroy methods).

2ï¸âƒ£ Bean Instantiation: 
	âœ” Spring creates the bean instance using the constructor.
	âœ” Object exists, but dependencies are not injected yet.

3ï¸âƒ£ Dependency Injection (Populate Properties)
	âœ” Injects dependencies via: Constructor / Setter / Field (@Autowired)
	
4ï¸âƒ£ Aware Interfaces (Optional)
	âœ” If implemented, Spring injects container context: BeanNameAware, BeanFactoryAware, ApplicationContextAware
	
5ï¸âƒ£ BeanPostProcessor â€” Before Initialization [postProcessBeforeInitialization(bean, beanName)]
	âœ” Used for: Validation, Pre-init customization, Framework logic

6ï¸âƒ£ Initialization Phase (IMPORTANT) : Spring runs any/all of the following in order:
	âœ” a) @PostConstruct (Recommended)
	âœ” b) InitializingBean.afterPropertiesSet()
	âœ” c) Custom init-method : @Bean(initMethod = "customInit")

7ï¸âƒ£ BeanPostProcessor â€” After Initialization [postProcessAfterInitialization(bean, beanName)]
	âœ” AOP proxies (@Transactional, @Async) are created here.

8ï¸âƒ£ Bean is READY to Use ğŸ‰: 
	âœ” Fully initialized, Dependencies injected, Proxies applied (if any), Available from ApplicationContext

8ï¸âƒ£  Destruction Phase (Shutdown) 
	âœ” Triggered when: Application stops, Context is closed
	ğŸ§¹ Destruction callbacks (order):
		âœ” a) @PreDestroy
		âœ” b) DisposableBean.destroy()
		âœ” c) Custom destroy-method
âš ï¸ Called only for singleton beans
âš ï¸ Prototype beans are not destroyed by Spring

-------------------------------------------------------------
ğŸ”¹ Q4. How you will call the @Predestory marked methods in the standalone application.
-------------------------------------------------------------
ğŸ”‘ Key rule: @PreDestroy methods are called only when the Spring container is closed.
âœ” In a standalone (non-web) application, you must explicitly close the ApplicationContext.
	ğŸ§¹context.close(); 
	âœ… Using try-with-resources
	âœ… Alternative (Register shutdown hook): context.registerShutdownHook();
ğŸ”‘ Why @PreDestroy does NOT work for prototype scope:
	âœ…Spring manages the entire lifecycle of singleton beans, but only the creation phase of prototype beans.
ğŸ”‘ Then who should destroy prototype beans?
	ğŸ‘‰ Developer. TempBean bean = context.getBean(TempBean.class); bean.cleanup();
	ğŸ‘‰ Or implement AutoCloseable:
		public class TempBean implements AutoCloseable {
			@Override
			public void close() {
				// cleanup
			}
		}
ğŸ”‘ What happens in a Web Application?
	ğŸ‘‰ The Servlet container (Tomcat / Jetty / Undertow) controls the lifecycle.
	ğŸ‘‰ @PreDestroy methods are called automatically when the web application is shutting down.
âœ… Who triggers it internally?
	âœ”Classic Spring MVC (WAR) : ContextLoaderListener, Listens to servlet lifecycle, Calls contextDestroyed(), Closes Spring context
	âœ”Spring Boot: Embedded server, Spring Boot auto-registers shutdown hooks, Calls ApplicationContext.close()

-------------------------------------------------------------
ğŸ”¹ Q5. Explain the helper class that initializes and destroys the web application context.
-------------------------------------------------------------
ğŸ”‘ ContextLoaderListener is a Spring-provided ServletContext listener that bridges the servlet container lifecycle with the Spring IoC container.It initialize the root WebApplicationContext when the web app starts and destroy (close) the WebApplicationContext when the web app stops.

ğŸ”‘ Why is this helper class needed?: In a web application, the lifecycle is controlled by the Servlet container (Tomcat, Jetty, etc.), not by Spring. Spring needs a hook to Start the IoC container at application startup and Cleanly shut it down during application shutdown. â¡ï¸ ContextLoaderListener provides exactly this hook.

ğŸ”‘ What happens during Application Startup?
Web Container starts â†“ ServletContext initialized â†“ ContextLoaderListener.contextInitialized()
â†“ Spring creates Root WebApplicationContext â†“ Beans are instantiated & initialized

Internally: Reads contextConfigLocation, Creates the root application context, Stores it in ServletContext

ğŸ”‘ What happens during Application Shutdown?
Server stops / App undeployed â†“ ServletContext destroyed â†“ ContextLoaderListener.contextDestroyed() 
â†“ Spring closes ApplicationContext â†“ @PreDestroy / destroy() methods called

âœ” Proper cleanup, Resource release, Graceful shutdown

ğŸ”‘ Configuration (Classic Spring MVC â€“ WAR)
	web.xml
	<listener>
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/applicationContext.xml</param-value>
	</context-param>

ğŸ”‘ Root vs Servlet WebApplicationContext (IMPORTANT)
Spring web apps have two contexts: 
| Context                           | Created by              | Contains                            |
| --------------------------------- | ----------------------- | ----------------------------------- |
| **Root WebApplicationContext**    | `ContextLoaderListener` | Services, Repositories, DataSources |
| **Servlet WebApplicationContext** | `DispatcherServlet`     | Controllers, ViewResolvers          |


ğŸ”‘ Relationship with DispatcherServlet
	âœ” ContextLoaderListener â†’ initializes shared beans
	âœ” DispatcherServlet â†’ handles web layer only
	âœ” This separation: Improves modularity, Keeps web concerns isolated

ğŸ”‘ What about Spring Boot?
	âœ” You do not explicitly configure ContextLoaderListener
	âœ” Boot auto-configures it internally
	âœ” Lifecycle behavior remains the same

-------------------------------------------------------------
ğŸ”¹ Q5. What are all RestClients in spring?
-------------------------------------------------------------
ğŸ”‘ RestTemplate (Legacy â€“ synchronous)
	âœ” Where: Older Spring Boot (2.x) projects, Simple internal REST calls
	âœ” Why: Easy to use, Blocking & synchronous

ğŸ”‘ WebClient (Reactive & non-blocking)
	âœ” Where: Microservices, High-throughput systems, Parallel API calls
	âœ” Why: Non-blocking I/O, Better scalability, Supports reactive streams
	
ğŸ”‘ Spring RestClient (Spring 6+) â­ Preferred now
	âœ” Where: New Spring Boot 3 projects
	âœ” Why: Modern replacement for RestTemplate, Fluent, clean API, Still synchronous (easy to reason about)

ğŸ”‘ Feign Client (Declarative REST client)
	âœ” Where: Microservices (Spring Cloud), Service-to-service communication
	âœ” Why: Interface-based, Less boilerplate, Integrates well with load balancing & resilience
	
ğŸ”‘ Apache HttpClient (Low-level control)
	âœ” Where: Legacy systems, Custom SSL / proxy / timeout requirements
	âœ” Why: Full control over HTTP, Fine-grained configuration

-------------------------------------------------------------
ğŸ”¹ Q6. getForEntity() vs postForEntity()
-------------------------------------------------------------
| Aspect         | `getForEntity()` | `postForEntity()` |
| -------------- | ---------------- | ----------------- |
| HTTP Method    | GET              | POST              |
| Purpose        | Fetch data       | Create/send data  |
| Request Body   | âŒ No            | âœ… Yes           |
| Idempotent     | âœ… Yes           | âŒ No            |
| Cacheable      | âœ… Yes           | âŒ No            |
| Typical Status | 200 OK           | 201 Created       |
| Use case       | Read operations  | Create operations |

-------------------------------------------------------------
ğŸ”¹ Q7. What are the uses of ResponseEntity?
-------------------------------------------------------------
ResponseEntity<T> represents the entire HTTP response â€” status code, headers, and body.
1ï¸âƒ£ Control HTTP Status Codes : âœ… return ResponseEntity.status(HttpStatus.CREATED).body(user);
	âœ” Instead of always returning 200 OK, you can return meaningful REST status codes.
2ï¸âƒ£ Add / Modify HTTP Headers : âœ… return new ResponseEntity<>(user, headers, HttpStatus.OK);
	âœ” Used for: Authentication tokens, Location header, Caching, CORS, Custom metadata
3ï¸âƒ£ Return Response Body Conditionally
4ï¸âƒ£ Build RESTful Responses (Best Practice)
5ï¸âƒ£ Support Content Negotiation : âœ… return ResponseEntity.ok().contentType(MediaType.APPLICATION_JSON)body(user);
	âœ” ResponseEntity works with: Accept header, Message converters
6ï¸âƒ£ Handle Empty Responses Properly
7ï¸âƒ£ Centralized Error Handling Integration
8ï¸âƒ£ Generic & Type-safe Responses
9ï¸âƒ£ Avoid Using void or Raw Objects âŒ

-------------------------------------------------------------
ğŸ”¹ Q7. Why should you handle response timeout while calling any API?
-------------------------------------------------------------
ğŸ”‘ We handle response timeouts to avoid thread blocking, prevent cascading failures,
 protect system resources, and maintain predictable latency and SLAs.
1ï¸âƒ£ Prevent thread blocking & resource exhaustion
	âœ” Without a timeout, a client thread can wait forever.
	âœ” Under load, blocked threads exhaust pools â†’ system slowdown or crash.
	âœ” Timeout = fail fast and free resources.
	
2ï¸âƒ£ Avoid cascading failures
	âœ” One slow/downstream service can stall callers.
	âœ” Without timeouts, failures propagate across services.
	âœ” Timeouts isolate failures and keep the rest of the system responsive.

3ï¸âƒ£ Maintain predictable latency & SLAs
	âœ” APIs must respond within defined SLAs (e.g., 300â€“500 ms).
	âœ” Timeouts enforce upper bounds on waiting, keeping latency predictable.

4ï¸âƒ£ Enable resilience patterns
	âœ” Timeouts are prerequisites for:Retries, Circuit breakers, Fallbacks, Bulkheads
	âœ” No timeout â†’ these patterns canâ€™t trigger effectively.

5ï¸âƒ£ Protect against unreliable external dependencies
	âœ” Third-party APIs can hang, slow down, or partially fail.
	âœ” Timeouts protect your system from vendor/network issues.

6ï¸âƒ£ Improve user experience
	âœ” Users prefer quick failure with a clear error over infinite loading.
	âœ” Enables graceful degradation (cached data, partial responses).

7ï¸âƒ£ Security & abuse protection
	âœ” Prevents slow-response attacks (e.g., keeping connections open).
	âœ” Limits how long a malicious or buggy endpoint can tie up resources.

-------------------------------------------------------------
ğŸ”¹ Q8. Explain the differences between Server timeout and Read timeout.
-------------------------------------------------------------
ğŸ”‘ Server timeout limits how long the server is allowed to process a request,
while Read timeout limits how long the client waits to receive a response after sending the request.
1ï¸âƒ£ Server Timeout (Server-side)
	âœ” What: 
		ğŸ”¹Configured on the server / gateway / load balancer
		ğŸ”¹Maximum time allowed for request processing
		ğŸ”¹Includes business logic, DB calls, downstream calls
	âœ” What happens when it expires: Server stops processing, Returns an error response
	âœ” Common responses: 504 Gateway Timeout, 503 Service Unavailable, 500 Internal Server Error (implementation-specific)
	âœ” Typical places configured: API Gateway (Nginx, Kong), Load balancer, Application server (Tomcat, Undertow)

2ï¸âƒ£ Read Timeout (Client-side)
	âœ”	What:
		ğŸ”¹Configured on the client
		ğŸ”¹Maximum time client waits for response data
		ğŸ”¹Starts after request is sent and connection is established
	âœ”	What happens when it expires: Client throws a timeout exception, Connection is closed by the client
	âœ”	Common exceptions: SocketTimeoutException, ReadTimeoutException, WebClientRequestException

Case 1: Read timeout < Server timeout => Client times out first, Server may still process request (wasted work)
Case 2: Server timeout < Read timeout => Server fails fast, Client receives error response
ğŸ‘‰ Best practice: Server timeout â‰¤ Client read timeout

-------------------------------------------------------------
ğŸ”¹ Q9. What is versioning in Rest? what are the ways that you can use to implement versioning? 
-------------------------------------------------------------
ğŸ”‘ REST API versioning is the practice of managing breaking changes to an API so that existing clients continue to work while newer clients adopt updated behavior.
	ğŸ”¹Why:
		âœ” Clients depend on a stable contract
		âœ” Mobile apps canâ€™t upgrade instantly
		âœ” Third-party integrations must not break
		âœ” APIs evolve over time (fields change, behavior changes)

1ï¸âƒ£ URI (Path) Versioning â­ Most Common : GET /api/v2/users
2ï¸âƒ£ Query Parameter Versioning : GET /api/users?version=1
3ï¸âƒ£ Header Versioning (Custom Header): @GetMapping(value = "/users", headers = "X-API-VERSION=1")
4ï¸âƒ£ Media Type Versioning (Content Negotiation) â­ Most RESTful :
	@GetMapping(
	  value = "/users",
	  produces = "application/vnd.company.users-v1+json"
	)

-------------------------------------------------------------
ğŸ”¹ Q10. How does Basic Authentication work in Rest API?
-------------------------------------------------------------
ğŸ”‘ Basic Authentication is an HTTP authentication scheme where the client sends username and password (Base64-encoded) with every request via the Authorization header.
1ï¸âƒ£ Client requests a protected resources : GET /api/users
2ï¸âƒ£ Server challenges the client
	âœ” If no credentials are sent: 401 Unauthorized WWW-Authenticate: Basic realm="users"

3ï¸âƒ£ Client sends credentials: 
	âœ” Combines username:password, Encodes with Base64, Sends in header
	âœ” Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ= (username:password â†’ Base64)

4ï¸âƒ£ Server validates credentials
	âœ” Decodes Base64, Extracts username & password, Validates against DB / LDAP / IdP
5ï¸âƒ£ Server responds
	âœ… 200 OK â†’ valid credentials
	âŒ 401 Unauthorized â†’ invalid credentials

-------------------------------------------------------------
ğŸ”¹ Q11. Should you use JWT or Session-based authentication in the microservices environment? 
-------------------------------------------------------------
	| Aspect               | Session-based | JWT         |
	| -------------------- | ------------- | ----------- |
	| State                | Stateful      | Stateless   |
	| Scalability          | âŒ Poor      | âœ… Excellent|
	| Microservices fit    | âŒ No        | âœ… Yes      |
	| Cross-service calls  | Hard          | Easy        |
	| Infrastructure       | Session store | None        |
	| Cloud / K8s friendly | âŒ            | âœ…         |
	| Architecture         | Monolithic    | Microservice|

-------------------------------------------------------------
ğŸ”¹ Q12. What is content negotiation?
-------------------------------------------------------------
ğŸ”‘ Content negotiation allows a REST API to return different representations of the 
   same resource based on the clientâ€™s Accept header.
Why Content Negotiation is needed
	âœ” Different clients prefer different formats
	  ğŸ”¹Browsers â†’ HTML
	  ğŸ”¹Mobile apps â†’ JSON
	  ğŸ”¹Legacy systems â†’ XML
	âœ” One API serves multiple consumers
	âœ” Keeps URIs stable and resource-oriented

-------------------------------------------------------------
ğŸ”¹ Q13. What are the cross-cutting concerns in spring? how do you implement it in microservices architecture?
-------------------------------------------------------------
ğŸ”‘ Cross-cutting concerns are functionalities that span across multiple layers and modules
   of an application but are not part of core business logic.
	| Concern              | What it does                        |
	| -------------------- | ----------------------------------- |
	| Logging              | Method entry/exit, request/response |
	| Security             | Authentication & authorization      |
	| Transactions         | Commit / rollback management        |
	| Exception Handling   | Centralized error handling          |
	| Caching              | Performance optimization            |
	| Validation           | Input & business validation         |
	| Monitoring & Metrics | Health, performance                 |
	| Distributed Tracing  | Trace & correlation IDs             |
	| Auditing             | Who changed what & when             |
	| Rate Limiting        | Prevent abuse                       |

â“ Why handle them separately?
	âœ” Without separation: Code duplication, Tangled business logic, Hard maintenance, Inconsistent behavior
	âœ” Spring provides infrastructure mechanisms to keep business code clean.
	
1ï¸âƒ£ How Spring Implements Cross-Cutting Concerns (Core Concepts)
	ğŸ”¹A. Spring AOP â­â­â­â­â­: 	âœ” No code duplication, âœ” Applied uniformly
	ğŸ”¹B. Declarative Annotations: @Transactional, @Cacheable, @Async, @Secured

2ï¸âƒ£ Cross-Cutting Concerns in Microservices Architecture
ğŸ”¹API Gateway Level (Global): Tools => Spring Cloud Gateway, Nginx, Kong, AWS API Gateway
	| Concern         | How                     |
	| --------------- | ----------------------- |
	| Authentication  | OAuth2 / JWT validation |
	| Rate limiting   | Gateway filters         |
	| CORS            | Gateway configuration   |
	| Request logging | Global filters          |

ğŸ”¹Service Level (Spring AOP)
	| Concern            | Mechanism           |
	| ------------------ | ------------------- |
	| Transactions       | `@Transactional`    |
	| Logging            | AOP aspects         |
	| Validation         | Bean Validation     |
	| Caching            | `@Cacheable`        |
	| Exception handling | `@ControllerAdvice` |

ğŸ”¹Filter & Interceptor Level
	| Tool                | Use                       |
	| ------------------- | ------------------------- |
	| Servlet Filters     | Security, correlation IDs |
	| HandlerInterceptors | Request metadata          |
	| WebClient Filters   | Outgoing calls            |

ğŸ”¹Distributed Tracing (Microservices-specific): Tools => OpenTelemetry, Zipkin, Jaeger
	âœ” Correlation ID propagation, Trace ID / Span ID

ğŸ”¹Centralized Observability
	| Concern | Tool            |
	| ------- | --------------- |
	| Logs    | ELK / EFK       |
	| Metrics | Prometheus      |
	| Traces  | Jaeger / Zipkin |




-------------------------------------------------------------
ğŸ”¹ Q14. How to create custom validators in spring?
-------------------------------------------------------------
ğŸ”‘ A custom validator allows you to define your own validation rules beyond
   standard constraints (@NotNull, @Size, etc.) using Bean Validation (Jakarta Validation / JSR-380).
  
âœ… Recommended Way: Annotation-based Bean Validation
Step 1ï¸âƒ£ Create a Custom Constraint Annotation
	@Documented
	@Constraint(validatedBy = PasswordStrengthValidator.class)
	@Target({ ElementType.FIELD, ElementType.PARAMETER })
	@Retention(RetentionPolicy.RUNTIME)
	public @interface StrongPassword {
		String message() default "Password is too weak";
		Class<?>[] groups() default {};
		Class<? extends Payload>[] payload() default {};
	}
	
Step 2ï¸âƒ£ Implement ConstraintValidator
	public class PasswordStrengthValidator implements ConstraintValidator<StrongPassword, String> {

		@Override
		public boolean isValid(String value, ConstraintValidatorContext context) {
			if (value == null) return false;
			return value.length() >= 8 &&
				   value.matches(".*[A-Z].*") &&
				   value.matches(".*[0-9].*");
		}
	}

Step 3ï¸âƒ£ Use the Custom Validator
	public class UserRequest {

		@StrongPassword
		private String password;
	}

-------------------------------------------------------------
ğŸ”¹ Q15. How spring's singleton scope is different then GOF signleton?
-------------------------------------------------------------
1ï¸âƒ£ Spring Singleton Scope
	âœ” What: One bean instance per ApplicationContext, Managed by Spring container, Default scope in Spring
	âœ” Lifecycle is fully managed by Spring @PostConstruct/@PreDestroy, Easy to test and mock
	âœ” Clean DI, Loose coupling, Works with AOP, transactions, proxies

2ï¸âƒ£ GoF Singleton Pattern
	âœ” What: One instance per JVM, Enforced by code, No framework involved
	âœ” JVM-wide single instance, Global access, No lifecycle hooks
	âŒ Hard to test, Global state, Tight coupling, Thread-safety complexity, Cannot easily reset between tests

-------------------------------------------------------------
ğŸ”¹ Q16. Tell me some Spring Exceptions that you came across with example ?
-------------------------------------------------------------
1ï¸âƒ£ NoSuchBeanDefinitionException
	âœ” Why: Spring cannot find a required bean, Wrong package scanning, Missing implementation for an interface

2ï¸âƒ£ BeanCreationException
	âœ” Why: Bean fails during creation, Exception inside constructor or @PostConstruct

3ï¸âƒ£ UnsatisfiedDependencyException
	âœ” Why: Dependency chain cannot be resolved, Constructor injection failure, Circular dependency
	
4ï¸âƒ£ HttpRequestMethodNotSupportedException
	âœ” Why: Client uses wrong HTTP method, Endpoint mapping mismatch

5ï¸âƒ£ MethodArgumentNotValidException
	âœ” Occurs when validation fails. public void create(@Valid @RequestBody User user) {}

6ï¸âƒ£ TransactionRequiredException
	âœ” Why: Executing update/delete query without transaction

7ï¸âƒ£ InvalidDataAccessApiUsageException
	âœ” Why: Wrong JPA usage, Passing null or invalid arguments

8ï¸âƒ£ DataIntegrityViolationException
	âœ” Why: DB constraint violation, Unique key, Foreign key, Not null constraint

9ï¸âƒ£ OptimisticLockingFailureException
	âœ” Why: Concurrent update with @Version

ğŸ”Ÿ NoUniqueBeanDefinitionException
	âœ” why: Interface with multiple implementations
	âœ” Spring resolves dependencies in this order: By type, By name, By qualifier, By @Primary
		âœ… Option 1: @Primary (Most common)
		âœ… Option 2: @Qualifier (Best practice for clarity)
		âœ… Option 3: Inject by name: private PaymentService cardPaymentService;
		âœ… Option 4: Inject all implementations: private List<PaymentService> paymentServices; 


-------------------------------------------------------------
ğŸ”¹ Q17. Tell me 10 spring Annotations that you have used ? (Excluding the stereotype annotations)
-------------------------------------------------------------
1ï¸âƒ£ @Autowired: Purpose: Inject dependencies automatically.
2ï¸âƒ£ @Qualifier: Purpose: Resolve ambiguity when multiple beans of same type exist.
3ï¸âƒ£ @Primary: Purpose: Marks a bean as default choice.
4ï¸âƒ£ @Value: Purpose: Inject values from properties or environment.
5ï¸âƒ£ @Configuration: Purpose: Marks a class as Spring Java configuration.
6ï¸âƒ£ @Bean: Purpose: Manually register a bean.
7ï¸âƒ£ @Transactional: Purpose: Manage database transactions declaratively.
8ï¸âƒ£ @RequestMapping: Purpose: Map HTTP requests to controller methods.
9ï¸âƒ£ @RequestBody: Purpose: Bind HTTP request body to Java object.
ğŸ”Ÿ @PathVariable: Purpose: Extract values from URI path.
ğŸ¯ Bonus (Very commonly used â€“ if interviewer asks more)
@RequestParam, @ResponseStatus, @ExceptionHandler, @ControllerAdvice
@PostConstruct, @PreDestroy, @EnableCaching, @Cacheable, @Validated, @Profile

-------------------------------------------------------------
ğŸ”¹ Q18. Is it required to write @Repository annotations in spring data JPA?
-------------------------------------------------------------
ğŸ”‘ No, it is not required to explicitly write @Repository on Spring Data JPA repository interfaces.
	Spring Data JPA:
		âœ” Automatically detects the interface
		âœ” Creates a proxy implementation at runtime
		âœ” Registers it as a Spring bean
		âœ” Marks it internally as @Repository
		âœ” So exception translation and bean registration are already handled.
		âœ” Convert PersistenceException, SQLException into Springâ€™s DataAccessException

-------------------------------------------------------------
ğŸ”¹ Q19. Explain the Spring Data Project and the hierarchy ? 
-------------------------------------------------------------
ğŸŒ³ Repository Hierarchy (Most Important for Interviews)
Repository (marker interface) : Enables Spring Data repository detection, âœ” Base for all repositories
   â†“
CrudRepository : âœ” Store-independent, âœ” Works for SQL & NoSQL
   â†“
PagingAndSortingRepository: âœ” Pagination, âœ” Sorting
   â†“
JpaRepository (JPA-specific) : âœ” Hibernate/JPA optimizations, âœ” Batch operations, âœ” Most common in real projects

ğŸ”— How Spring Data works internally (Simplified)
Repository Interface
        â†“
Spring Data Proxy
        â†“
EntityManager / Template
        â†“
Database

No implementation written by developer, Proxy created at runtime, Queries derived from method names

-------------------------------------------------------------
ğŸ”¹ Q20. Use of  @NoRepositoryBean in spring boot ?
-------------------------------------------------------------
ğŸ”‘ @NoRepositoryBean is a Spring Data annotation used to tell Spring: â€œDo NOT create a repository bean for this interface.â€
	It is mainly used for base (parent) repository interfaces that are meant to be extended, not instantiated.
	By default, Spring Data tries to create a bean for every repository interface it finds. If you create a generic/base repository interface, Spring will: Try to create a proxy bean for it and Fail at startup (because it has no domain type) @NoRepositoryBean prevents this.
	âœ” Spring Data itself uses @NoRepositoryBean on: Repository, CrudRepository, PagingAndSortingRepository
	ğŸ‘‰ Thatâ€™s why Spring doesnâ€™t try to create beans for them

-------------------------------------------------------------
ğŸ”¹ Q21. Different types of bean scope presenet in spring and its use case ?
-------------------------------------------------------------
ğŸ”‘ What is a Bean Scope in Spring: A bean scope defines how many instances of a bean Spring creates
   and how long that instance lives within the container.
   
   1ï¸âƒ£ singleton (Default & Most Used): One bean instance per Spring ApplicationContext, Shared across the entire application
   2ï¸âƒ£ prototype: New instance every time getBean() is called, Spring manages creation only, not destruction.
		@Component
		@Scope("prototype")
		public class ReportGenerator {}

   3ï¸âƒ£ request (Web Scope): One bean per HTTP request, Exists only during a single request
		@Component
		@Scope(value = WebApplicationContext.SCOPE_REQUEST)
		public class RequestContext {}

	4ï¸âƒ£ session (Web Scope): One bean per HTTP session, Shared across multiple requests of the same user
		@Component
		@Scope(value = WebApplicationContext.SCOPE_SESSION)
		public class UserSession {}
	
	5ï¸âƒ£ application (Web Scope): One bean per ServletContext, Similar to singleton, but web-specific
		@Component
		@Scope(value = WebApplicationContext.SCOPE_APPLICATION)
		public class AppMetadata {}

	6ï¸âƒ£ websocket (Specialized Web Scope): One bean per WebSocket session
		@Scope("websocket")
		@Component
		public class WebSocketSessionBean {}
   
-------------------------------------------------------------
ğŸ”¹ Q22. What is limitations of java config file?
-------------------------------------------------------------
	1ï¸âƒ£ Tight Coupling Between Configuration & Code
		What: Configuration is written in Java
		Any config change requires: Code change, Recompile, Redeploy, 
		Example
			@Bean
			public DataSource dataSource() {
				return new HikariDataSource();
			}

			â¡ï¸ Changing pool type = code change

		Why itâ€™s a limitation: Ops/DevOps cannot change config easily, Not ideal for runtime-only configuration

	2ï¸âƒ£ Less Runtime Flexibility Compared to XML / Properties
		XML / properties allow
		datasource.pool.size=20

		Java config requires
		dataSource.setMaximumPoolSize(20);

		â¡ï¸ Harder to externalize complex configurations

	3ï¸âƒ£ Harder for Non-Java Users
		XML / YAML can be edited by: Ops, Support teams, 
		Java config requires: Java knowledge, IDE, Build process, ğŸ‘‰ Not business-friendly

	4ï¸âƒ£ Verbosity for Large Configurations 
		Example: Large security / integration config
		Java config: Long, Hard to scan visually, Mixed with logic
		XML/YAML: More declarative, Easier to review

	5ï¸âƒ£ Harder to Enable/Disable Config Dynamically
		Java config: Conditional logic must be coded
		@ConditionalOnProperty(name = "feature.enabled", havingValue = "true")
		Compared to XML
		<beans profile="prod">
	ğŸ‘‰ XML / profiles can feel simpler for environment-based switching

	6ï¸âƒ£ Accidental Business Logic in Configuration 
		Java config is Turing complete.
			@Bean
			public ObjectMapper mapper() {
				if (env.acceptsProfiles("prod")) {
					return prodMapper();
				}
				return devMapper();
			}
		âš ï¸ Risk: Logic-heavy config, Hard to test, Violates separation of concerns

	7ï¸âƒ£ Startup Time Slightly Higher (Edge Case)
		Java config: Class loading, Reflection
		XML: Simple parsing
		 Usually negligible, but relevant in very large apps

	8ï¸âƒ£ Not Ideal for Pure Configuration Data
		Example: Feature flags, Routing rules, Large static mappings
		Better stored in: YAML / properties, External config servers, Databases
		
		
-------------------------------------------------------------
ğŸ”¹ Q23. How a CGLIB Proxy works with @Bean?
-------------------------------------------------------------
ğŸ”‘ Spring uses a CGLIB-generated subclass for @Configuration classes to 
	intercept @Bean method calls and ensure that the container returns the same 
	managed bean instance instead of creating new objects.

	âœ” When Spring sees @Configuration, internally creates something like AppConfig$$EnhancerBySpringCGLIB$$123
	âœ” A subclass of AppConfig, Generated at runtime using CGLIB
	âœ” @Configuration Uses CGLIB proxy to Ensures full singleton semantics
	âœ” @Configuration(proxyBeanMethods = false) : âŒ No CGLIB proxy, âœ” Faster startup, âœ” Less memory
	âš ï¸ BUT: Calling one @Bean from another creates a new instance, Safe only when @Bean methods are independent

-------------------------------------------------------------
ğŸ”¹ Q24. Difference between creating a bean with @Bean and @Component ? 
-------------------------------------------------------------
ğŸ”‘ @Component creates beans through classpath scanning for application classes
	âœ” Bean lifecycle managed normally, Created during component scan
	
ğŸ”‘ @Bean explicitly defines beans in configuration classes and is mainly used for third-party or complex bean creation.
	âœ” Lifecycle depends on @Configuration, Uses CGLIB proxying to preserve singleton semantics
	
â“ Can @Bean be used without @Configuration?
	âœ” Yes, but: Singleton behavior may break, CGLIB proxying wonâ€™t apply
	
-------------------------------------------------------------
ğŸ”¹ Q25. What is a BeanFactoryPostProcessor?
-------------------------------------------------------------
ğŸ”‘ BeanFactoryPostProcessor is a Spring extension point that allows 
   you to modify bean definitions (metadata) before any beans are instantiated.
	âœ” Runs after bean definitions are loaded
	âœ” Runs before any bean objects are created
	âœ” Can change how beans will be created, not the bean instances themselves
	ğŸ‘‰ It works on BeanDefinition, not on actual beans.

â“ Why do we need it?
	âœ” Change property values dynamically
	âœ” Register beans programmatically
	âœ” Enable environment-specific configuration
	âœ” Apply framework-level customization
	
ğŸ“Œ Simple example
		@Component
		public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

			@Override
			public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
				BeanDefinition bd = beanFactory.getBeanDefinition("dataSource");
				bd.getPropertyValues().add("maximumPoolSize", 50);
			}
		}

ğŸ“Œ Built-in examples: PropertySourcesPlaceholderConfigurer, ConfigurationClassPostProcessor

| Aspect         | BeanFactoryPostProcessor | BeanPostProcessor   |
| -------------- | ------------------------ | ------------------- |
| Operates on    | Bean definitions         | Bean instances      |
| Execution time | Before instantiation     | After instantiation |
| Access to bean | âŒ No                    | âœ… Yes             |
| Typical usage  | Config, metadata         | AOP, proxies        |

-------------------------------------------------------------
ğŸ”¹ Q26. What do you mean by a @Transactional Annotation and explain the Transactional Propagation in spring?
-------------------------------------------------------------
ğŸ”‘ @Transactional is a declarative transaction management annotation in Spring that
   ensures a group of database operations execute as one atomic unit.
	âœ” All operations succeed â†’ COMMIT
	âœ” Any failure â†’ ROLLBACK
	âœ” Spring implements @Transactional using AOP proxies, so transaction logic is applied without polluting business code.

ğŸ”¹ Key properties of @Transactional
	@Transactional(
		propagation = Propagation.REQUIRED,
		isolation = Isolation.READ_COMMITTED,
		rollbackFor = Exception.class,
		timeout = 5
	)
| Property      | Purpose                         |
| ------------- | ------------------------------- |
| `propagation` | How transactions interact       |
| `isolation`   | DB isolation level              |
| `rollbackFor` | Which exceptions cause rollback |
| `timeout`     | Max execution time              |
| `readOnly`    | Optimization for read queries   |

ğŸ”‘ Transaction propagation defines how a transactional method behaves when it is called by another transactional method.
	âœ” In simple terms: Should it join an existing transaction or create a new one?
	1ï¸âƒ£ REQUIRED (Default & Most Used) â­â­â­â­â­ @Transactional(propagation = Propagation.REQUIRED)
		âœ” Behavior: Join existing transaction, Create new if none exists
		âœ” Use case: Service layer business logic, âœ” Safe default, âœ” Most common
	
	2ï¸âƒ£ REQUIRES_NEW : @Transactional(propagation = Propagation.REQUIRES_NEW)
		âœ” Behavior: Always creates a new transaction, Suspends existing one
		âœ” Use case: Audit logging, Notifications, Independent commits
		âš ï¸ Outer transaction rollback does NOT affect this one
	
	3ï¸âƒ£ SUPPORTS : @Transactional(propagation = Propagation.SUPPORTS)
		âœ” Behavior: Uses existing transaction if present, Executes without transaction otherwise
		âœ” Use case: Read-only operations
	
	4ï¸âƒ£ NOT_SUPPORTED: @Transactional(propagation = Propagation.NOT_SUPPORTED)
		âœ” Behavior: Suspends existing transaction, Always executes non-transactionally
		âœ” Use case: Logging, Monitoring, External calls
	
	5ï¸âƒ£ MANDATORY : @Transactional(propagation = Propagation.MANDATORY)
		âœ” Behavior: Must run inside an existing transaction, Throws exception if none exists
		âœ” Use case: Critical internal methods, Enforce transaction boundary
	
	6ï¸âƒ£ NEVER : @Transactional(propagation = Propagation.NEVER)
		âœ” Behavior: Must NOT run inside a transaction, Throws exception if transaction exists
		âœ” Use case: Explicitly non-transactional logic
	
	7ï¸âƒ£ NESTED (Advanced) : @Transactional(propagation = Propagation.NESTED)
		âœ” Behavior: Creates a nested transaction, Uses savepoints
		âœ” Use case: Partial rollback scenarios
		âš ï¸ Requires DB support (savepoints)

	â“ Default rollback behavior? : âœ” Rollback on unchecked exceptions only

ğŸ”‘ Isolation defines how visible the data changes of one transaction are to other concurrent transactions.
	Spring delegates isolation handling to the database, and you control it
	using:@Transactional(isolation = Isolation.READ_COMMITTED)
	
	1ï¸âƒ£ READ_UNCOMMITTED (Lowest isolation)
		âœ” What it allows: âŒ Dirty reads, âŒ Non-repeatable reads, âŒ Phantom reads
		âœ” Use case: Almost never used, Rare reporting scenarios
	
	2ï¸âƒ£ READ_COMMITTED (Most common default)
		âœ” What it prevents: âœ… Dirty reads
		âœ” What it allows: âŒ Non-repeatable reads, âŒ Phantom reads
		âœ” Use case: Default for Oracle, PostgreSQL, Most CRUD applications
	
	3ï¸âƒ£ REPEATABLE_READ
		âœ” What it prevents: âœ… Dirty reads, âœ… Non-repeatable reads
		âœ” What it allows: âŒ Phantom reads
		âœ” Use case: Financial calculations, Consistent reads within a transaction
	
	4ï¸âƒ£ SERIALIZABLE (Highest isolation)
		âœ” What it prevents: âœ… Dirty reads, âœ… Non-repeatable reads, âœ… Phantom reads
		âœ” Use case: Critical financial systems, Strong consistency requirements
		âš ï¸ Performance cost is high
	
	ğŸ‘‰ Spring isolation works only if DB supports it.

-------------------------------------------------------------	
ğŸ”¹ Q27. Explain optimistic vs pessimistic locking ?
-------------------------------------------------------------
	1ï¸âƒ£ Optimistic Locking
	ğŸ”¸ Core idea: Assume conflicts are rare. Donâ€™t lock data while reading; check for conflicts at update time.
		âœ” How it works: 
			Add a version field to the entity, Every update checks the version, If version changed â†’ fail the update
			
			@Entity
			public class Product {
				@Id
				private Long id;
				private int quantity;

				@Version
				private int version;
			}
			
		âœ” Pros : High performance, No database locks, Scales well, Ideal for read-heavy systems
		âœ” Cons : âŒ Update may fail, âŒ Requires retry logic
		âœ” Best use cases: High-read, low-write systems, Web apps, REST APIs, Microservices, User-driven updates
		
	2ï¸âƒ£ Pessimistic Locking
	ğŸ”¸ Core idea: Assume conflicts are likely. Lock data upfront so no one else can modify it.
		âœ” How it works:
			DB acquires a lock when data is read, Other transactions must wait.
			
			@Lock(LockModeType.PESSIMISTIC_WRITE)
			@Query("select p from Product p where p.id = :id")
			Product findForUpdate(@Param("id") Long id);
		
		âœ” Pros : Strong consistency, No update conflicts, Predictable behavior
		âœ” Cons : âŒ Lower concurrency, âŒ Risk of deadlocks, âŒ Slower under load
		âœ” Best use cases: High-contention updates, Financial transactions, Inventory reservations, Critical sections
		
-------------------------------------------------------------	
ğŸ”¹ Q28. How the dispatcher servlet is set up in a spring boot project gets auto-configured?
-------------------------------------------------------------
ğŸ”‘ In Spring Boot, DispatcherServlet is auto-configured through Spring Boot Auto-Configuration (spring-boot-autoconfigure)
   using DispatcherServletAutoConfiguration, so developers donâ€™t need to define it manually in web.xml or Java config.
   
   1ï¸âƒ£ What happens in traditional Spring MVC (before Boot): You had to manually configure:
		<servlet>
		  <servlet-name>dispatcher</servlet-name>
		  <servlet-class> org.springframework.web.servlet.DispatcherServlet</servlet-class>
		</servlet>
		<servlet-mapping>
		  <servlet-name>dispatcher</servlet-name>
		  <url-pattern>/</url-pattern>
		</servlet-mapping>
	
	2ï¸âƒ£ What Spring Boot does instead (High level)
	Spring Boot automatically: 
		Detects a web environment, Creates a DispatcherServlet bean,
		Registers it with the embedded servlet container, Maps it to / , Wires all MVC infrastructure beans
		â¡ï¸ Zero manual configuration
	
	3ï¸âƒ£ The key auto-configuration classes (Interview Gold)
		Spring Boot uses: DispatcherServletAutoConfiguration, WebMvcAutoConfiguration
		These classes live inside spring-boot-autoconfigure.
	
	4ï¸âƒ£ Step-by-step auto-configuration flow
	âœ… Step 1: Application startup: Boot creates ApplicationContext, Detects Servlet Web Application
	âœ… Step 2: Auto-configuration kicks in @SpringBootApplication includes: @EnableAutoConfiguration
		This tells Spring Boot to: Load auto-config classes from META-INF/spring.factories (or AutoConfiguration.imports in newer versions)
	âœ… Step 3: DispatcherServlet bean creation: Inside DispatcherServletAutoConfiguration:
				@Bean
				@ConditionalOnMissingBean
				public DispatcherServlet dispatcherServlet() {
					return new DispatcherServlet();
				}
		âœ” Created only if you didnâ€™t define one
		âœ” Prevents duplication
	âœ… Step 4: Servlet registration : Spring Boot registers the servlet using:
		ServletRegistrationBean<DispatcherServlet>, Default mapping: / , Name: dispatcherServlet
	âœ… Step 5: MVC infrastructure wiring: WebMvcAutoConfiguration configures:
		HandlerMapping, HandlerAdapter, ViewResolver, HttpMessageConverters, Exception resolvers
		So your controllers just work:

		@RestController
		public class UserController {

		  @GetMapping("/users")
		  public List<User> users() {
			return List.of();
		  }
		}

	5ï¸âƒ£ Why no web.xml in Spring Boot?
		Because: Boot uses embedded servlet containers (Tomcat/Jetty/Undertow)
		Programmatic servlet registration replaces web.xml
		ğŸ‘‰ This is why Spring Boot apps are standalone & executable

	6ï¸âƒ£ Default DispatcherServlet configuration in Boot
	| Setting         | Default                       |
	| --------------- | ----------------------------- |
	| Servlet name    | `dispatcherServlet`           |
	| URL mapping     | `/`                           |
	| Load on startup | 1                             |
	| Context         | Servlet WebApplicationContext |

	7ï¸âƒ£ Can you customize DispatcherServlet? (Yes)
		Example: Change mapping : spring.mvc.servlet.path=/api

		Example: Custom DispatcherServlet bean
		@Bean
		public DispatcherServlet dispatcherServlet() {
			DispatcherServlet ds = new DispatcherServlet();
			ds.setThrowExceptionIfNoHandlerFound(true);
			return ds;
		}
		Boot backs off automatically.

â“ What enables this auto-configuration?: ğŸ‘‰ @EnableAutoConfiguration
â“ What if I add @EnableWebMvc?: ğŸ‘‰ âŒ Boot MVC auto-configuration is disabled

-------------------------------------------------------------
ğŸ”¹ Q29. How will you handle exceptions in spring?
-------------------------------------------------------------
ğŸ”‘ In Spring, exceptions are handled using local handlers, global handlers with
   @ControllerAdvice, ResponseEntityExceptionHandler, and custom exceptions, 
   ensuring consistent HTTP responses and clean separation of error logic from business code.
   
   1ï¸âƒ£ Local Exception Handling (@ExceptionHandler): Scope: One controller
   
		@ExceptionHandler(UserNotFoundException.class)
		public ResponseEntity<String> handle(UserNotFoundException ex) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
		}
		
		âœ” Pros: Simple, Good for controller-specific errors
		âœ” Cons: Not reusable, Leads to duplication
	
	2ï¸âƒ£ Global Exception Handling (@ControllerAdvice / @RestControllerAdvice) â­â­â­â­â­ Scope: Entire application
	
		@RestControllerAdvice
		public class GlobalExceptionHandler {
		
			@ExceptionHandler(UserNotFoundException.class)
			public ResponseEntity<ApiError> handleNotFound(UserNotFoundException ex) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiError(404, ex.getMessage()));
			}
		}
		
		âœ” Why itâ€™s preferred: Centralized, Consistent responses, Clean controllers
	
	3ï¸âƒ£ Extend ResponseEntityExceptionHandler (Validation & MVC errors) : Useful for overriding built-in Spring MVC exceptions.
	
		@RestControllerAdvice
		public class ValidationHandler extends ResponseEntityExceptionHandler {

			@Override
			protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex,
					HttpHeaders headers, HttpStatusCode status, WebRequest request) {
				return ResponseEntity.badRequest().body("Validation failed");
			}
		}
		
		âœ” Handles: MethodArgumentNotValidException, HttpMessageNotReadableException, HttpRequestMethodNotSupportedException

-------------------------------------------------------------
ğŸ”¹ Q30. Difference between @ControllerAdvice and @RestControllerAdvice?
-------------------------------------------------------------
ğŸ”‘ @ControllerAdvice is a global advice for MVC controllers that typically returns views or responses
   @RestControllerAdvice is specialized for REST APIs and automatically returns JSON/XML responses using @ResponseBody.
   
   1ï¸âƒ£ @ControllerAdvice : 
	âœ” A specialization of @Component. Applies globally to all @Controller classes, Used in Spring MVC (server-side rendering)
	âœ” Default behavior: Methods return => View names, ModelAndView, Or response with @ResponseBody (if specified)

		@ControllerAdvice
		public class GlobalExceptionHandler {

			@ExceptionHandler(Exception.class)
			public String handleError(Exception ex, Model model) {
				model.addAttribute("error", ex.getMessage());
				return "error"; // view name
			}
		}

	âœ” When to use : JSP / Thymeleaf apps, Mixed MVC + REST apps

	2ï¸âƒ£ @RestControllerAdvice:
	âœ” Combination of: @ControllerAdvice + @ResponseBody
	âœ” Default behavior: Return value is written directly to HTTP response body, Automatically serialized (JSON/XML)

		@RestControllerAdvice
		public class GlobalExceptionHandler {

			@ExceptionHandler(UserNotFoundException.class)
			public ResponseEntity<ApiError> handle(UserNotFoundException ex) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND)
									 .body(new ApiError(404, ex.getMessage()));
			}
		}

	âœ” When to use: REST APIs, Microservices, JSON/XML responses only

	â“ Can @ControllerAdvice return JSON? âœ” Yes, but only if: @ResponseBody is used on method
	â“ Should we use @RestControllerAdvice for REST apps? âœ” Yes â€” best practice
	â“ Can both exist in the same app? âœ” Yes â€” Spring will apply both as needed

-------------------------------------------------------------
ğŸ”¹ Q31. What happens internally when you use @Autowired?
-------------------------------------------------------------
ğŸ”‘ When @Autowired is used, Spring performs dependency injection at runtime
 by resolving a matching bean from the ApplicationContext and injecting it using reflection,
 during the BeanPostProcessor phase of the bean lifecycle.

	ğŸ‘‰ @Autowired happens after object creation but before initialization.
	âœ” Spring uses a special BeanPostProcessor called: AutowiredAnnotationBeanPostProcessor
		ğŸ”¹Class responsible: Detecting @Autowired, Resolving dependencies, Injecting them into fields/constructors/methods
		ğŸ”¹Dependency resolution order: By type => @Qualifier => @Primary => By bean name
		ğŸ”¹Spring uses Java Reflection: field.setAccessible(true); field.set(orderService, paymentServiceBean);
	âœ” Constructor vs Field vs Setter injection (Internal behavior)
		ğŸ”¹Constructor injection (Preferred): Injection happens at creation time, Ensures immutability, No reflection hacks
		ğŸ”¹Field injection: âŒ Uses reflection, âŒ Harder to test
		ğŸ”¹Setter injection: Optional dependencies

-------------------------------------------------------------
ğŸ”¹ Q32. Compare @Autowired vs @Inject vs @Resource
-------------------------------------------------------------
| Feature               | `@Autowired`                 | `@Inject`  | `@Resource` |
| --------------------- | ---------------------------- | ---------- | ----------- |
| Standard              | Spring                       | JSR-330    | JSR-250     |
| Injection default     | By type                      | By type    | By name     |
| Qualifier support     | `@Qualifier`                 | `@Named`   | âŒ          |
| Optional injection    | `required=false`, `Optional` | `Optional` | âŒ          |
| Primary support       | âœ…                           | âŒ        | âŒ          |
| Static fields         | âŒ                           | âŒ        | âŒ          |
| Constructor injection | âœ…                           | âœ…        | âŒ          |
| Spring features       | Full                         | Limited    | Limited     |

-------------------------------------------------------------
ğŸ”¹ Q33. How will you handle a Bad gateway exception when thrown from a rest client ?
-------------------------------------------------------------
ğŸ”‘ A 502 means: Your service (gateway / client) received an invalid or no response from an upstream service.
  Typical causes: Downstream service is down, Timeout/connection reset, Load balancer issues, DNS/network problems

ğŸ”‘ Handle a 502 from a REST client by catching client exceptions, mapping them to meaningful responses,
 adding retries with backoff, timeouts, and fallbacks, and logging with correlation IDs.
 
 1ï¸âƒ£ Handling 502 with RestTemplate: HttpServerErrorException.BadGateway
 2ï¸âƒ£ Add Retries with Backoff (Production-grade)
		@Retryable(
		  value = DownstreamServiceException.class,
		  maxAttempts = 3,
		  backoff = @Backoff(delay = 1000, multiplier = 2)
		)
		public Order getOrder(Long id) {
			return callOrderService(id);
		}
	âš ï¸ Retry only for: GET, Idempotent calls
 3ï¸âƒ£ Timeouts (Must-have)
		HttpComponentsClientHttpRequestFactory factory =
        new HttpComponentsClientHttpRequestFactory();
		factory.setConnectTimeout(3000);
		factory.setReadTimeout(3000);

		RestTemplate restTemplate = new RestTemplate(factory);
 4ï¸âƒ£ Circuit Breaker (Microservices best practice)
		@CircuitBreaker(name = "orderService", fallbackMethod = "fallback")
		public Order getOrder(Long id) {
			return callOrderService(id);
		}

		public Order fallback(Long id, Throwable ex) {
			return Order.empty();
		}

-------------------------------------------------------------
ğŸ”¹ Q34. How a spring boot application bootstraps ?
-------------------------------------------------------------
1ï¸âƒ£ Entry point: main() â†’ SpringApplication.run() : This single call triggers the entire startup lifecycle.
2ï¸âƒ£ What @SpringBootApplication really does
	Itâ€™s a meta-annotation: @SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan
	âœ” @Configuration â†’ Java config class
	âœ” @ComponentScan â†’ finds beans
	âœ” @EnableAutoConfiguration â†’ magic of Boot

3ï¸âƒ£ Startup lifecycle (inside SpringApplication.run()): 
	âœ” 1: Create SpringApplication: 
			ğŸ”¹Determines application type: SERVLET (Tomcat), REACTIVE (Netty), NONE (CLI)
			ğŸ”¹Loads SpringApplicationRunListeners

	âœ” 2: Prepare Environment:
			ğŸ”¹Reads configuration from: application.properties/yaml, OS env variables, JVM system properties, Command-line args
			ğŸ”¹Resolves profiles (dev, prod, etc.)

	âœ” 3: Create ApplicationContext:
			ğŸ”¹Chooses context based on app type:
				AnnotationConfigServletWebServerApplicationContext
				AnnotationConfigReactiveWebServerApplicationContext

	âœ” 4: Load Auto-Configuration â­â­â­â­â­:
			ğŸ”¹Triggered by @EnableAutoConfiguration
			ğŸ”¹Boot scans auto-config classes declared in:
				META-INF/spring.factories (Boot â‰¤ 2.x)
				META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports (Boot 3.x)
			
			ğŸ”¹Each auto-config is guarded by conditions: 
				@ConditionalOnClass, @ConditionalOnMissingBean, @ConditionalOnProperty
			
			ğŸ‘‰ Classpath + properties decide what gets configured

	âœ” 5: Component Scanning & Bean Definitions
			ğŸ”¹Scans packages starting from main class
			ğŸ”¹Registers: @Component, @Service, @Repository, @Controller, @Configuration

	âœ” 6: BeanFactory & Bean lifecycle
			ğŸ”¹Bean definitions finalized
			ğŸ”¹Executes: BeanFactoryPostProcessor, Bean instantiation, @Autowired injection, BeanPostProcessor, @PostConstruct

	âœ” 7: Start Embedded Web Server (if web app)
			ğŸ”¹Boot creates and starts: Tomcat / Jetty / Undertow
			ğŸ”¹Registers: DispatcherServlet, Filters, Controllers, No web.xml needed.

	âœ” 8: Application Ready
			ğŸ”¹Publishes lifecycle events: ApplicationStartedEvent, ApplicationReadyEvent

	App is now ready to handle requests.
	

-------------------------------------------------------------
ğŸ”¹ Q39. What is Spring Boot Actuator and how it works ?
-------------------------------------------------------------
ğŸ”‘ Spring Boot Actuator is a Spring Boot module that provides production-ready features
   to monitor, manage, and observe your application at runtime.
   In simple words: Actuator exposes internal application information through HTTP/JMX endpoints.

1ï¸âƒ£ Why do we need Actuator? (The Problem)
	In production, teams need answers to:
		âœ” Is the application up or down?
		âœ” Is the database connected?
		âœ” How many requests are coming?
		âœ” What is the memory/CPU usage?
		âœ” Are threads blocked or leaking?

2ï¸âƒ£ How to enable Actuator : add dependency
		<dependency>
		  <groupId>org.springframework.boot</groupId>
		  <artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>

3ï¸âƒ£ How Actuator works internally (Step-by-step)
	1ï¸âƒ£ Auto-configuration
		âœ” Spring Boot auto-configures: Health indicators, Metrics collectors, Endpoint handlers
		âœ” Using: @ConditionalOnClass, @ConditionalOnProperty

	2ï¸âƒ£ Endpoint registration
		âœ” Each actuator endpoint is registered as: HTTP endpoint (REST), JMX bean (optional)
		âœ” Example: /actuator/health, /actuator/metrics
	
	3ï¸âƒ£ Data collection
		âœ” Actuator gathers data from: JVM, Spring context, DataSource, Thread pools, Custom indicators

	4ï¸âƒ£ Exposure & security
		âœ” Endpoints are: Disabled by default (except health), Exposed explicitly via configuration, Protected by Spring Security

	4ï¸âƒ£ Common Actuator Endpoints (VERY IMPORTANT)
	| Endpoint               | Purpose                |
	| ---------------------- | ---------------------- |
	| `/actuator/health`     | Application health     |
	| `/actuator/info`       | App info               |
	| `/actuator/metrics`    | JVM & app metrics      |
	| `/actuator/env`        | Environment properties |
	| `/actuator/beans`      | Spring beans           |
	| `/actuator/mappings`   | Request mappings       |
	| `/actuator/loggers`    | Change log levels      |
	| `/actuator/threaddump` | Thread dump            |
	| `/actuator/heapdump`   | Heap dump              |

	5ï¸âƒ£ Health Endpoint (Deep dive â€“ Interview Gold)
		âœ” GET /actuator/health
		âœ” Aggregates multiple health checks
		âœ” Used by load balancers & Kubernetes

	6ï¸âƒ£ Metrics Endpoint (Micrometer integration)
		âœ” GET /actuator/metrics/jvm.memory.used
		âœ” Metrics include: JVM memory, GC, HTTP request count, Response time, Thread count
		âœ” Actuator uses Micrometer internally and can export metrics to: Prometheus, Grafana, CloudWatch

	7ï¸âƒ£ Securing Actuator (VERY IMPORTANT)
		âŒ Exposing everything publicly is dangerous
		âœ” Best practice
				management.endpoints.web.exposure.include=health,info,metrics
				management.endpoint.health.show-details=when_authorized
		âœ” Limit exposure, Secure with roles, Never expose sensitive endpoints publicly

	8ï¸âƒ£ Custom Actuator Endpoints
		âœ” Custom Health Indicator
				@Component
				public class PaymentHealthIndicator implements HealthIndicator {

					@Override
					public Health health() {
						if (paymentServiceUp()) {
							return Health.up().build();
						}
						return Health.down().withDetail("error", "Payment down").build();
					}
				}

		âœ” Automatically added to: /actuator/health

	9ï¸âƒ£ Actuator in Microservices (Real-world usage)
		âœ” Used for:, Kubernetes liveness/readiness probes, Auto-scaling decisions, Centralized monitoring, Alerting
		âœ” /actuator/health/liveness, /actuator/health/readiness

-------------------------------------------------------------
How does AOP work internally?
-------------------------------------------------------------
âœ” SOAP is a strict XML-based protocol with built-in standards for security and transactions
âœ” REST is a lightweight architectural style that leverages HTTP semantics for scalable and flexible APIs.

| Aspect         | SOAP                  | REST                       |
| -------------- | --------------------- | -------------------------- |
| Type           | Protocol              | Architectural style        |
| Data format    | XML only              | JSON, XML, Text, etc.      |
| Transport      | HTTP, SMTP, JMS       | HTTP                       |
| Contract       | WSDL (mandatory)      | Optional (OpenAPI/Swagger) |
| State          | Can be stateful       | Stateless                  |
| Performance    | Slower (XML overhead) | Faster (lightweight)       |
| Ease of use    | Complex               | Simple                     |
| Error handling | SOAP Fault            | HTTP status codes          |

-------------------------------------------------------------
How did you handle security in your Spring boot based application ?
-------------------------------------------------------------
-------------------------------------------------------------
What are the differences between SOAP and REST Webservices?
-------------------------------------------------------------

-------------------------------------------------------------
How did you optimize your application ?
-------------------------------------------------------------


-------------------------------------------------------------
How do you secure REST APIs without using Spring Security? (Filters, interceptors, gateway rules, custom tokens, etc.)
-------------------------------------------------------------
Without Spring Security, I secure REST APIs using custom filters or interceptors for authentication, typically with JWT or API keys. Authorization is enforced manually using roles from tokens, combined with HTTPS, rate limiting, and infrastructure-level security.
Custom Servlet Filter
Register Filter
API Key Authentication

-------------------------------------------------------------
Explain internal working of REST Template & WebClient and which one you prefer.
-------------------------------------------------------------
ğŸ”¹ Step-by-Step Execution Flow
1ï¸âƒ£ Your code calls: restTemplate.getForObject(url, Response.class);
2ï¸âƒ£ RestTemplate: Creates a ClientHttpRequest, Serializes request body using HttpMessageConverters
3ï¸âƒ£ ClientHttpRequestFactory: Uses underlying HTTP client
	âœ” SimpleClientHttpRequestFactory â†’ JDK HttpURLConnection
	âœ” HttpComponentsClientHttpRequestFactory â†’ Apache HttpClient
4ï¸âƒ£ Thread blocks until: Response is received, Response body is deserialized
5ï¸âƒ£ Control returns to calling thread

ğŸ”¹ Step-by-Step Execution Flow
1ï¸âƒ£ Your code calls:
		webClient.get()
			.uri(url)
			.retrieve()
			.bodyToMono(Response.class);

2ï¸âƒ£ WebClient: Builds request using fluent API, Does NOT block the thread
3ï¸âƒ£ Request handled by Reactor Netty: Uses event-loop threads, No thread per request
4ï¸âƒ£ Response arrives: Callback (Mono / Flux) is triggered, Data flows downstream
5ï¸âƒ£ Thread is released immediately after request initiation



Must Practice: Why @Transactional fails sometimes
Self-invocation problem


 


