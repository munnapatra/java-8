ğŸŒ MICROSERVICES / SYSTEM DESIGN (Very Important)

-------------------------------------------------------------
ğŸ”¹ Q35. REST API Best practices
-------------------------------------------------------------
1ï¸âƒ£ Resource-oriented URLs (Nouns, not verbs)
	âŒ Bad : /getUsers, /createOrder
	âœ… Good: /users, /order âœ” Use plural nouns, âœ” Use hierarchy only when needed

2ï¸âƒ£ Use correct HTTP methods
	| Method | Purpose        |
	| ------ | -------------- |
	| GET    | Read           |
	| POST   | Create         |
	| PUT    | Full update    |
	| PATCH  | Partial update |
	| DELETE | Delete         |

3ï¸âƒ£ Proper HTTP Status Codes â­â­â­â­â­
	| Scenario         | Status          |
	| ---------------- | --------------- |
	| Success GET      | 200 OK          |
	| Resource created | 201 Created     |
	| No content       | 204 No Content  |
	| Bad request      | 400 Bad Request |
	| Unauthorized     | 401             |
	| Forbidden        | 403             |
	| Not found        | 404             |
	| Conflict         | 409             |
	| Server error     | 500             |
	| Bad gateway      | 502             |

4ï¸âƒ£ Consistent Response Structure
5ï¸âƒ£ Validation & Meaningful Errors
	âœ” Validate inputs at boundaries
	âœ” Return clear validation messages
	âœ” Use: @Valid, Global exception handler
	
6ï¸âƒ£ Versioning the API (Must-have)
	âœ” Common approaches: /api/v1/users OR Accept: application/vnd.myapp.v1+json
	âœ” Avoid breaking existing clients

7ï¸âƒ£ Pagination, Sorting & Filtering
	âŒ Returning 10k records
	âœ… Use: GET /users?page=0&size=20&sort=name,asc

8ï¸âƒ£ Security Best Practices â­â­â­â­â­
	âœ” Always use HTTPS
	âœ” Use JWT / OAuth2
	âœ” Do not expose internal errors
	âœ” Validate tokens on every request
	âŒ Never rely on client-side validation

9ï¸âƒ£ Idempotency (Important for retries)
	| Method | Idempotent  |
	| ------ | ----------- |
	| GET    | âœ…          |
	| PUT    | âœ…          |
	| DELETE | âœ…          |
	| POST   | âŒ (usually)| For POST: Use Idempotency-Key header

ğŸ”Ÿ Timeout, Retry & Resilience : Avoid cascading failures in microservices.
	âœ” Set client timeouts
	âœ” Retry only idempotent calls
	âœ” Use circuit breakers

1ï¸âƒ£1ï¸âƒ£ Caching & Performance
	âœ” Use HTTP caching headers: ETag, Cache-Control
	âœ” Enable server-side caching where applicable

1ï¸âƒ£2ï¸âƒ£ Content Negotiation : Avoid format-based URLs.
	âœ” Support: Accept: application/json
	âœ” Return: Content-Type: application/json

1ï¸âƒ£3ï¸âƒ£ Logging & Observability
	âœ” Log: Request ID / correlation ID, Errors with context
	âœ” Expose: Health checks, Metrics, Traces

1ï¸âƒ£4ï¸âƒ£ Documentation (Non-negotiable)
	âœ” Use OpenAPI / Swagger
	âœ” Keep examples updated
	âœ” Document error responses

-------------------------------------------------------------
ğŸ”¹ Q36. Monolithic Architecture Vs Microservices Architecture
-------------------------------------------------------------
ğŸ”‘ Monolithic Architecture: 
	A single, unified application where all modules (UI, business logic, data access) 
	are built, deployed, and scaled together.

ğŸ”‘ Microservices Architecture: 
	An architectural style where the application is split into small, independent services, 
	each responsible for a specific business capability, deployed and scaled independently.

2ï¸âƒ£ Key Differences (Interview Gold)
	| Aspect         | Monolithic  | Microservices  |
	| -------------- | ----------- | -------------- |
	| Codebase       | Single      | Multiple small |
	| Deployment     | Single unit | Independent    |
	| Scalability    | Whole app   | Per service    |
	| Technology     | One stack   | Polyglot       |
	| Database       | Usually one | DB per service |
	| Failure impact | Entire app  | Isolated       |
	| Testing        | Simpler     | Complex        |
	| Ops complexity | Low         | High           |

4ï¸âƒ£ Scalability
	âœ”Monolithic: Scale vertically or replicate whole app, Inefficient resource usage
	âœ”Microservices: Scale only hot services, Horizontal scaling is natural

9ï¸âƒ£ When to use which? (Real-world decision)
	âœ”Monolithic: Small to medium application, Small team, Simple domain, Fast initial development
	âœ”Microservices: Large, complex domain, Independent scaling needed, Multiple teams, High availability required

-------------------------------------------------------------
ğŸ”¹ Q37. How to manage ipâ€™s and servers in a microservices architecture
-------------------------------------------------------------
ğŸ”‘ Core problem In microservices: 
		âœ”Services are dynamic
		âœ”IPs change due to: Auto-scaling, Container restarts, Node failures, Hardcoding IPs âŒ does not work
		âœ”So we need dynamic service discovery + routing.
		
1ï¸âƒ£ Why hardcoding IPs fails âŒ
	Problems: 
		âœ”Pod restarts â†’ IP changes
		âœ”Scaling â†’ multiple instances
		âœ”Failures â†’ stale IPs
		âœ”Environment differences (dev/qa/prod)
		ğŸ‘‰ Hardcoding = brittle system

2ï¸âƒ£ Service Discovery (MOST IMPORTANT) â­â­â­â­â­
	âœ”A mechanism where Services register themselves Other services discover them dynamically
	âœ”Types of Service Discovery
		ğŸ”¹Client-side discovery : Client â†’ Service Registry â†’ Target Service
			Examples: Eureka, Consul, Zookeeper
		ğŸ”¹Server-side discovery (More common today) : Client â†’ Load Balancer â†’ Service
			Examples: Kubernetes, AWS ALB/NLB, Cloud load balancers
			
4ï¸âƒ£ API Gateway (External traffic management)
	âœ”Responsibilities: Single entry point, Routing to services, Authentication, Rate limiting, SSL termination
	âœ”Gateway routes using: Service names, Logical routes, Not IPs

5ï¸âƒ£ Load Balancers (Internal & External)
	âœ”External Load Balancer: Handles internet traffic, Routes to gateway or services
	âœ”Internal Load Balancer: Balances traffic between service instances
	âœ”Benefits: No IP awareness in clients, Fault tolerance, Scalability

6ï¸âƒ£ DNS-based service resolution
	âœ”Instead of: http://10.0.1.12:8080 Use: http://order-service:8080
	âœ”DNS resolves: Service name â†’ current healthy instances
	âœ”DNS is often backed by: Kubernetes DNS, Cloud DNS, Service mesh

7ï¸âƒ£ Service Mesh (Advanced / Large scale)
	âœ”Examples: Istio, Linkerd
	âœ”What it adds: Sidecar proxies, mTLS, Traffic routing, Observability
	
-------------------------------------------------------------
ğŸ”¹ Q38. How Service Discovery and Registration works ? ( A problem Scenario )
-------------------------------------------------------------
ğŸ”´ Imagine a microservices system with Order Service calling Payment Service.
âŒ Naive approach (hardcoded IP) : Order Service â†’ http://10.0.1.12:8080/pay
ğŸ”‘ What goes wrong? : 
	âœ”Payment Service restarts â†’ IP changes
	âœ”Auto-scaling adds more instances
	âœ”Failures make IP unreachable
	âœ”Multiple environments (dev/qa/prod)
	Result: Order Service breaks frequently

ğŸ‘‰ This is the core problem service discovery solves.
âœ… The Solution: Service Discovery & Registration
	âœ”Core idea: Services register themselves on startup, and clients discover them dynamically at runtime.

ğŸ§© Key Components
	âœ”Service Provider â€“ e.g., Payment Service
	âœ”Service Registry â€“ Central directory
	âœ”Service Consumer â€“ e.g., Order Service

ğŸŸ¢ Step-by-Step Flow (Problem â†’ Solution)
	1ï¸âƒ£ Service starts â†’ Registration
		âœ” When Payment Service starts: Payment Service â†’ Service Registry
		âœ” Happens automatically on startup
		âœ” Updated on restart or scale-up
		
	2ï¸âƒ£ Heartbeat mechanism (Health check)
		âœ” Payment Service â†’ Registry (heartbeat every 30s)
		âœ” If heartbeats stop: Registry marks instance DOWN, Removes it from active list
		âœ” Prevents calling dead services
	
	3ï¸âƒ£ Client wants to call a service â†’ Discovery
		âœ” Order Service needs Payment Service: Order Service â†’ Registry â†’ List of Payment Service instances
	
	4ï¸âƒ£ Load balancing & call
		âœ” Order Service: Picks one instance (round-robin), Makes the call
		âœ”	Order Service â†’ Payment Service (chosen instance)
		âœ” No IP hardcoding, Load balanced, Fault tolerant

ğŸ§  Two Discovery Models (Interview Must-Know)
	1ï¸âƒ£ Client-side Discovery: 
		âœ” Client â†’ Service Registry â†’ Service
		âœ” How it works: Client queries registry, Client chooses instance, Client does load balancing
		âœ” Examples: Eureka, Consul
		âœ” Flexible, âŒ Client complexity

	2ï¸âƒ£ Server-side Discovery (Most common today)
		âœ” Client â†’ Load Balancer â†’ Service
		âœ” How it works: Client calls a logical service name, Platform resolves & routes
		âœ” Examples: Kubernetes, Cloud Load Balancers
		âœ” Simple clients, Platform-managed

How do you design a rate-limiting system?
How do you handle distributed transactions?
What is circuit breaker?
How do you ensure idempotency?
What is eventual consistency?
Difference between synchronous vs asynchronous communication.
How do you handle API versioning?
How do you design highly available systems?
What is CAP theorem?
How do you secure microservices?
REST API design
Rate limiting
Circuit breaker
Idempotency
Must Practice: Designing scalable APIs
Handling distributed transactions
-------------------------------------------------------------
How Client side load balancing different then the Server Side load balancing ?
-------------------------------------------------------------
-------------------------------------------------------------
Is server side load balancing causes a single point of failure?
-------------------------------------------------------------
-------------------------------------------------------------
How to handle failure in a microservices environment ?
-------------------------------------------------------------
-------------------------------------------------------------
How the retry pattern works ?
-------------------------------------------------------------
-------------------------------------------------------------
How a block thread causes issue in a microservices environment ?
-------------------------------------------------------------
-------------------------------------------------------------
How to protect your microservices from random load?
-------------------------------------------------------------
-------------------------------------------------------------
Explain the states of a  circuit breaker in spring boot
-------------------------------------------------------------
-------------------------------------------------------------
How to track a slower Microservice which causes performance issue?
-------------------------------------------------------------
-------------------------------------------------------------
How to track exceptions in a microservices environment ?
-------------------------------------------------------------
-------------------------------------------------------------
Explain API Gateway responsibilities in microservices architecture.
-------------------------------------------------------------
-------------------------------------------------------------
How will you design rate-limiting for an API?
-------------------------------------------------------------
ğŸ”¹ 1. Fixed Window: How it works: Count requests in a fixed time window
ğŸ”¹ 2. Sliding Window (Improved Fixed Window): Tracks requests more accurately using timestamps.


-------------------------------------------------------------
Q13. How do you ensure fault tolerance in microservices? 
-------------------------------------------------------------
Ensuring fault tolerance in microservices means designing your system so that it continues to function properly even if some of its components fail. In distributed systems, failures are inevitable â€” network issues, service crashes, timeouts, etc. Fault-tolerant microservices absorb these failures and fail gracefully instead of bringing the entire system down.
Key Concepts to Ensure Fault Tolerance in Microservices
Circuit Breaker Pattern
Retry Mechanism
Timeouts
Fallback Methods
Bulkhead Pattern
Load Balancing
Service Discovery and Self-Healing
Health Checks
Asynchronous Communication
Graceful Degradation