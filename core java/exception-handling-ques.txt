1Ô∏è‚É£ Core & Fundamentals (But Asked Deeply)
===========================================================================================================
üîπ Q1. What is the difference between Error and Exception?
===========================================================================================================
	1Ô∏è‚É£ Position in the Exception Hierarchy
	Throwable
	 ‚îú‚îÄ‚îÄ Error
	 ‚îî‚îÄ‚îÄ Exception
		  ‚îî‚îÄ‚îÄ RuntimeException

	2Ô∏è‚É£ Error ‚Äî JVM / System-Level Failures
		Error represents: Serious problems related to: JVM, Memory, Class loading, Stack, Usually unrecoverable
		Examples: OutOfMemoryError, StackOverflowError, NoClassDefFoundError, InternalError
		Key Characteristics: 
			
			Indicates JVM may be in an unstable state
			Applications should not try to handle them
		
		üìå Senior insight: Catching an Error often makes things worse, not better.

	3Ô∏è‚É£ Exception ‚Äî Application-Level Failures
		Exception represents: Conditions that can occur during normal program execution, Usually recoverable or manageable
		Examples: IOException. SQLException, NullPointerException, IllegalArgumentException
		
		Two Types
		| Aspect             | Checked Exception      | Unchecked Exception  |
		| ------------------ | ---------------------- | -------------------- |
		| Compile-time check | ‚úî Yes           	  | ‚ùå No          	     |
		| Use case           | Recoverable conditions | Bugs / logic errors  |
		| Examples           | IOException            | NullPointerException |
		| Handling           |Musthandled or declared | Programming errors   |

	4Ô∏è‚É£ Handling Philosophy (Very Important)
		Should You Catch Error? ‚ùå No, except: Logging, Emergency shutdown, Metrics
		Should You Catch Exception? ‚úî Yes, when you can add value: Recovery, Translation, Context enrichment

	6Ô∏è‚É£ What Happens If They Are Not Caught?
		| Scenario             | Result                                 |
		| -------------------- | -------------------------------------- |
		| Uncaught `Exception` | Thread terminates                      |
		| Uncaught `Error`     | Thread terminates, JVM may be unstable |

		JVM does not crash immediately, but behavior is unpredictable after an Error.

===========================================================================================================
üîπ Q2. Why is Throwable the root class of exceptions?
===========================================================================================================
	1Ô∏è‚É£ JVM Needs One Universal Failure Type
		When something goes wrong, the JVM must be able to create the failure, attach a stack trace, propagate it up the call stack
		and decide whether it can be caught or must terminate the thread To do this consistently, the JVM needs one common base type that type is Throwable.
		Without it, the JVM would need special logic for every failure kind.

	2Ô∏è‚É£ Throwable Encapsulates What All Failures Need
		Every abnormal condition‚Äîno matter needs: A message, A stack trace, A cause (chaining), The ability to be thrown and caught
		Throwable provides exactly that: getMessage(), getStackTrace(), getCause(), fillInStackTrace()
		üìå Key insight: Throwable is not about what failed, but how failures are represented and propagated.

	3Ô∏è‚É£ JVM Uses Throwable Internally (Very Important)
		Internally, the JVM:
			Throws only Throwable objects
			Walks the stack looking for handlers of Throwable
			Terminates threads based on uncaught Throwable
			
		Even things like: OutOfMemoryError, StackOverflowError are still Throwable, so the JVM can uniformly unwind the stack.

		üìå Interview gold line: ‚ÄúThe JVM doesn‚Äôt care whether it‚Äôs an Error or Exception‚Äîit cares that it‚Äôs a Throwable.‚Äù

	4Ô∏è‚É£ Why You Should NOT Extend Throwable Directly
		Even though you can, you shouldn‚Äôt.
			why: It bypasses checked/unchecked semantics, Breaks tooling expectations, Confuses API users
		Best practice: Extend Exception or RuntimeException, Never extend Throwable directly

	5Ô∏è‚É£ Why Throwable Is Not Meant to Be Caught Generally
		Catching Throwable means: You catch Error, You catch things you cannot safely recover from
		That‚Äôs why catching Throwable is almost always a code smell.

===========================================================================================================
üîπ Q3. Difference between checked and unchecked exceptions ‚Äî and why Java designed them?
===========================================================================================================
	1Ô∏è‚É£ What Are Checked Exceptions?
		Definition: 
			Checked exceptions are enforced by the compiler‚Äîyou must either handle them using try-catch, or declare them using throws
		
		Examples: IOException, SQLException, FileNotFoundException
		Characteristics: Part of the method contract, Represent recoverable or expected failures, Encourage explicit error handling
		void readFile() throws IOException { }
		üìå Design intent: ‚ÄúThe caller must consciously decide how to handle this failure.‚Äù

	2Ô∏è‚É£ What Are Unchecked Exceptions?
		Definition:
			Unchecked exceptions are not enforced by the compiler. They extend RuntimeException.

		Examples: NullPointerException, IllegalArgumentException, IndexOutOfBoundsException
		Characteristics: Represent programming bugs, Usually not recoverable, Should fail fast

		void process(int x) {
			if (x < 0) throw new IllegalArgumentException();
		}
		üìå Design intent: ‚ÄúFix the code, don‚Äôt catch the exception.‚Äù

	3Ô∏è‚É£ Why Java Designed Checked Exceptions (Historical Context)
		When Java was designed (mid-1990s):
			Enterprise systems were monolithic
			Reliability was critical
			Failures like I/O, network, DB were common
			Silent failures were unacceptable
		
		Java‚Äôs Goal: Force developers to think about failure paths.
		Checked exceptions were meant to: Prevent ignored failures, Make APIs self-documenting, Improve robustness

	4Ô∏è‚É£ Why Unchecked Exceptions Exist (Not all failures should be handled.)
		Unchecked exceptions exist because: 
			Some errors indicate broken logic
			Handling them locally often hides bugs
			They should propagate and crash fast
		üìå Key insight: Catching a NullPointerException usually makes things worse.
		
	üìå Modern Java Best Practice (What Interviewers Like)
		Libraries: often throw unchecked exceptions
		Applications: handle exceptions at boundaries
		Recoverable failures: checked or domain-specific exceptions
		Programming errors: unchecked exceptions

===========================================================================================================
üîπ Q4. Why is RuntimeException unchecked?
===========================================================================================================
	RuntimeException is unchecked because it represents programming errors that are not meaningfully recoverable. Forcing callers to handle or declare them would add boilerplate without improving correctness, so Java lets them fail fast and be fixed at the code level.

	Can we catch Error? Should we?: 
	Yes, we can catch Error, but we generally should not, because Error represents serious JVM-level problems that applications cannot safely recover from.

===========================================================================================================
üîπ Q5. What happens if an exception is not handled?
===========================================================================================================
If an exception is not handled, it propagates up the call stack. If no handler is found, the JVM‚Äôs default exception handler prints the stack trace and terminates the current thread. If it‚Äôs the main thread, the application exits; otherwise, only that thread dies.

===========================================================================================================
üîπ Q6. Difference between throw and throws.
===========================================================================================================
1Ô∏è‚É£ throw ‚Äî Actually Throwing an Exception
	Key Points
		Only one exception can be thrown at a time
		Must be an instance of Throwable
		Transfers control immediately to the nearest matching catch

2Ô∏è‚É£ throws ‚Äî Declaring Possible Exceptions
	Key Points
		Can declare multiple exceptions
		Mostly relevant for checked exceptions
		Does not throw anything by itself
		
| Aspect                   | `throw`                  | `throws`                    |
| ------------------------ | ------------------------ | --------------------------- |
| Purpose                  | Throw an exception       | Declare possible exceptions |
| Where used               | Inside method/block      | Method signature            |
| Number allowed           | One at a time            | Multiple                    |
| Involves object creation | ‚úî Yes              	  | ‚ùå No          	            |
| Checked exception impact | Must be handled/declared | Enforces handling by caller |

===========================================================================================================
üîπ Q7. What is the default exception handler in JVM?
===========================================================================================================
When an exception is not caught, the JVM invokes the default UncaughtExceptionHandler, which prints the stack trace and terminates the current thread. If it‚Äôs the main thread, the application exits; otherwise, only that thread stops.

	What Actually Happens (Step by Step)
		An exception is thrown.
		JVM searches the call stack for a matching catch.
		No handler found ‚Üí exception is uncaught.
		JVM invokes the default UncaughtExceptionHandler.
			It: Prints exception type, message, and stack trace to stderr and Terminates the current thread
			
	Where the Default Handler Lives
		Defined by the Thread class
		Internally handled by: Thread.UncaughtExceptionHandler
		The JVM provides a default implementation if you don‚Äôt set one.

	What Exactly Gets Terminated?
		üîπ If it‚Äôs the main thread: JVM exits, Application stops
		üîπ If it‚Äôs a worker / background thread: Only that thread dies, JVM keeps running
		üìå Interview gold line: ‚ÄúUnhandled exceptions kill threads, not the JVM.‚Äù
		
		Can We Override the Default Handler?: ‚úî Yes
			Per-Thread
			thread.setUncaughtExceptionHandler((t, e) -> {
				log.error("Thread failed: " + t.getName(), e);
			});

			Global (All Threads)
			Thread.setDefaultUncaughtExceptionHandler((t, e) -> {
				log.error("Unhandled exception", e);
			});


		üìå Common in: Application servers, Frameworks, Logging/monitoring agents

	Why This Matters in Production
		Without a custom handler: Threads may die silently, Errors may be logged only to console, Failures can go unnoticed
		With a handler: Centralized logging, Alerts, Graceful shutdown triggers


===========================================================================================================
üîπ Q8. finally block execution process
===========================================================================================================
‚úÖ When finally DOES execute
	1Ô∏è‚É£ Normal execution
	2Ô∏è‚É£ Exception occurs (caught or not): ‚úî finally runs even if exception is uncaught
	3Ô∏è‚É£ return inside try or catch : ‚úî finally runs before the method returns
	4Ô∏è‚É£ Exception in catch: ‚úî finally still runs
	
‚ùå When finally DOES NOT execute 
	1Ô∏è‚É£ System.exit() is called: ‚ùå JVM terminates ‚Üí finally never runs
	2Ô∏è‚É£ JVM crash / kill: JVM crash, OS kill (kill -9), Power failure, ‚ùå No chance for finally
	3Ô∏è‚É£ Fatal JVM errors (rare): 
		Examples: OutOfMemoryError (in some cases), Stack corruption, JVM internal failure, ‚ùå Execution may stop before finally
		
‚ö†Ô∏è Tricky but IMPORTANT case 
	try { return 1; } finally { return 2; } : finally overriding return or exception ‚û°Ô∏è Returned value = 2
	try { throw new RuntimeException(); } finally { return 10; } 
		‚û°Ô∏è Exception is swallowed üò± üìå Never return from finally ‚Äî big code smell.
	try { int x = 10 / 0; } finally { throw new RuntimeException("From finally"); }
		‚û°Ô∏è Output: RuntimeException: Finally exception ‚ùå The ArithmeticException is completely lost, This makes debugging painful.
	try { return 1; } finally { throw new RuntimeException("Boom"); } ‚û°Ô∏è Method throws exception, Return value is discarded
	
üß† Golden interview rule: finally executes unless the JVM itself stops executing.

===========================================================================================================
üîπ Q9. What is multi-catch? Rules for multi-catch exception types and why exceptions in multi-catch are implicitly final?
===========================================================================================================
‚úÖ Multi-catch allows you to catch multiple exception types in a single catch block using the pipe (|) operator.
	‚úî Introduced in Java 7, Reduces duplicate catch blocks, Improves readability

üìú Rules for multi-catch exception types 
	1Ô∏è‚É£ Exceptions must be disjoint (not related by inheritance)
		‚ùå Not allowed: catch (Exception | IOException e) { }
		Why: IOException is a subclass of Exception, The broader type would already catch it
		‚úî Allowed: catch (IOException | SQLException e) { }
	
	2Ô∏è‚É£ Cannot mix checked and unchecked incorrectly
		You can mix them, but method signature rules still apply.
		catch (IOException | RuntimeException e) { } // this is allowed but Checked exceptions must be declared or handled properly, Compiler enforces this at method level
	
	3Ô∏è‚É£ Order of catch blocks still matters
		Multi-catch must respect top-down exception handling.
		try {
			...
		} catch (IOException | SQLException e) {
			...
		} catch (Exception e) {  // ‚úî broader exception later
			...
		}
		‚ùå Reverse order causes compile-time error.
	
	4Ô∏è‚É£ The catch parameter type is implicitly final üö®
		catch (IOException | SQLException e) {
			e = new IOException(); // ‚ùå compile-time error
		}
		You cannot reassign e.

ü§î Why are exceptions in multi-catch implicitly final? 
		This is the key interview ‚Äúwhy‚Äù question. Reason
		1Ô∏è‚É£: Type safety: 
			Inside multi-catch:
				catch (IOException | SQLException e)
				The compiler treats e as: Exception e   // common supertype
				If reassignment were allowed: e = new IOException();
				Now the compiler would lose track of: Which original exception was thrown, Whether later code is type-safe
				Making e final preserves the original runtime type.

		2Ô∏è‚É£: JVM & bytecode simplicity
			Java uses one catch block, No runtime switching between types
			final guarantees: No mutation, Predictable control flow

		3Ô∏è‚É£: Prevents subtle bugs
			If reassignment were allowed: Original exception could be lost, Stack trace manipulation bugs, Confusing debugging scenarios
			Java designers chose safety over flexibility.

‚ö†Ô∏è Important clarification 
	This rule applies only to multi-catch.
	Single catch: 
		catch (IOException e) {
			e = new IOException(); // ‚úî allowed (but discouraged)
		}
	
	Multi-catch:
		catch (IOException | SQLException e) {
			e = ... // ‚ùå NOT allowed
		}

‚úÖ Best practices for multi-catch 
	‚úî Use multi-catch when handling logic is identical
	‚úî Log or wrap exceptions, don‚Äôt mutate them
	‚úî Prefer specific handling when behavior differs
	
===========================================================================================================
üîπ Q10. How do you create a custom exception? Should custom exceptions be checked or unchecked?
===========================================================================================================
‚úÖ How do you create a custom exception?
	Decide the base class
	Checked exception ‚Üí extend Exception
	Unchecked exception ‚Üí extend RuntimeException
	üìå Best practice: Provide message-only and message + cause constructors, Don‚Äôt add unnecessary state unless required

‚úÖ Should custom exceptions be checked or unchecked?
	üëâ There is no universal rule ‚Äî it depends on who can reasonably recover.

‚úÖ When to use checked exceptions 
	Use checked exceptions when: Caller can and should recover, Error is part of normal business flow, You want to force handling
	Examples: Insufficient balance, Order not found, Validation failures, Business rule violations
	public void placeOrder() throws InsufficientBalanceException: ‚úî Forces caller to decide how to handle it

‚úÖ When to use unchecked exceptions
	Use unchecked exceptions when: Programming errors, Invalid API usage, System failures, Recovery is not realistic at that layer
	Examples: Null arguments, Illegal state, Configuration errors
	throw new IllegalStateException("Config not loaded"); ‚úî Cleaner APIs, Less boilerplate

üß† Modern Java best practice 
	Most custom exceptions should be unchecked.
	Why: Checked exceptions don‚Äôt scale well, They leak implementation details, They cause catch-and-wrap antipatterns
	Frameworks like: Spring, Hibernate, JPA ‚û°Ô∏è Prefer unchecked exceptions

‚úÖ Hybrid strategy (very common in real projects)
	Domain layer ‚Üí checked exceptions (business rules)
	Service / framework layer ‚Üí unchecked exceptions
	API boundary ‚Üí translate to error responses
	
===========================================================================================================
üîπ Q11. How do you add contextual data to an exception?
===========================================================================================================
‚úÖ What does ‚Äúcontextual data‚Äù mean? Contextual data = extra information that explains why and where the exception happened.
	Examples: IDs (userId, orderId), Input values, State information, Correlation / request IDs, Root cause details

‚úÖ Ways to add contextual data to an exception
	1Ô∏è‚É£ Add context in the exception message (simplest)
			throw new OrderNotFoundException(
				"Order not found. orderId=" + orderId
			);
		‚úî Simple, ‚úî Easy to log, ‚ùå Hard to parse programmatically

	2Ô∏è‚É£ Wrap the original exception (exception chaining) ‚≠ê
			catch (SQLException e) {
				throw new OrderProcessingException( "Failed to process orderId=" + orderId, e );
			}
		‚úî Preserves root cause, ‚úî Full stack trace, ‚úî Best practice 
		üìå Always include the cause when rethrowing.

	3Ô∏è‚É£ Add fields to a custom exception (structured context)
			public class OrderProcessingException extends RuntimeException {

				private final long orderId;
				private final String step;

				public OrderProcessingException(
						long orderId, String step, Throwable cause) {
					super("Order " + orderId + " failed at step " + step, cause);
					this.orderId = orderId;
					this.step = step;
				}

				public long getOrderId() { return orderId; }
				public String getStep() { return step; }
			}
		
		‚úî Strong typing, ‚úî Programmatic access, ‚úî Excellent for monitoring & APIs

	4Ô∏è‚É£ Use suppressed exceptions (Java 7+)
		Useful when multiple failures happen together.

			try {
				process();
			} catch (Exception e) {
				Exception cleanupEx = cleanup();
				e.addSuppressed(cleanupEx);
				throw e;
			}
		‚úî Keeps primary failure, ‚úî Adds secondary context, ‚úî Used heavily in try-with-resources

	5Ô∏è‚É£ Attach context via logging frameworks (MDC)
		Not inside the exception object, but very powerful.
			MDC.put("orderId", orderId);
			MDC.put("requestId", requestId);
			Log output: orderId=42 requestId=abc123 Failed to process order
		
		‚úî No exception pollution, ‚úî Great for distributed systems, ‚ùå Context lost if not logged

	6Ô∏è‚É£ Use error codes (API-friendly)
			throw new BusinessException( ErrorCode.ORDER_NOT_FOUND, "Order not found for id=" + orderId );
		
		‚úî Stable contracts, ‚úî Easy client mapping, ‚úî Good for REST APIs

‚ùå What NOT to do: 
	Swallow original exception, Overload exception with huge objects, Store mutable state, Log + throw same exception repeatedly

‚≠ê Best-practice pattern (real-world) 
		catch (Exception e) {
			throw new OrderProcessingException( orderId, "PAYMENT", e );
		}
	Then at the boundary: log.error("Order failed", e);
	
===========================================================================================================
üîπ Q12. How do you design exception hierarchy for large systems?
===========================================================================================================
1Ô∏è‚É£ Core principles for exception hierarchy design
	üß† Principle 1: Exceptions represent failure domains
			Each layer has its own exception family.
			API / Controller
			Service / Domain
			Infrastructure (DB, MQ, HTTP)
			üëâ Never leak lower-layer exceptions upward.

	üß† Principle 2: Catch low, throw high: Catch technical exceptions early, Throw meaningful domain exceptions upward
	üß† Principle 3: Unchecked by default: Use unchecked (RuntimeException) for scalability, Checked only when caller must recover

2Ô∏è‚É£ Typical exception hierarchy for large systems
	Root exception (application-wide)
		public abstract class ApplicationException extends RuntimeException {

			private final String errorCode;

			protected ApplicationException(String errorCode, String message, Throwable cause) {
				super(message, cause);
				this.errorCode = errorCode;
			}

			public String getErrorCode() {
				return errorCode;
			}
		}
	
	‚úî Centralized behavior, ‚úî Error code support, ‚úî Root for all app failures

3Ô∏è‚É£ Layered exception structure (recommended)
	üîπ Domain / Business exceptions:
		Represent business rule violations
			public abstract class BusinessException extends ApplicationException {
				protected BusinessException(String code, String message) {
					super(code, message, null);
				}
			}
		
		Examples: OrderNotFoundException, InsufficientBalanceException, InvalidOrderStateException
		‚úî Meaningful, ‚úî Recoverable, ‚úî Maps cleanly to API errors

	üîπ Service-level exceptions:
		Used for orchestration failures
			public class ServiceException extends ApplicationException {
				public ServiceException(String code, String message, Throwable cause) {
					super(code, message, cause);
				}
			}
		
		Examples: Payment processing failed, Workflow execution failed

	üîπ Infrastructure / Technical exceptions:
		Wrap low-level failures
			public class InfrastructureException extends ApplicationException {
				public InfrastructureException(String code, String message, Throwable cause) {
					super(code, message, cause);
				}
			}

		Examples: Database unavailable, Timeout calling external API, Messaging failure
		‚úî Never expose SQLException, IOException, etc.

4Ô∏è‚É£ Example: Exception translation across layers
	Repository layer
		catch (SQLException e) {
			throw new InfrastructureException( "DB_ERROR", "Database access failed", e );
		}

	Service layer
		catch (InfrastructureException e) {
			throw new ServiceException( "ORDER_PROCESSING_FAILED", "Failed to process order " + orderId, e );
		}

	API layer
		@ExceptionHandler(BusinessException.class)
		public ResponseEntity<ApiError> handleBusiness(BusinessException e) {
			return ResponseEntity.badRequest().body(new ApiError(e.getErrorCode(), e.getMessage()));
		}

5Ô∏è‚É£ Error codes: mandatory at scale üî¢
	Why error codes matter: Stable contracts, Easier client handling, Safer than message parsing
		ORDER_NOT_FOUND, PAYMENT_DECLINED, INVENTORY_UNAVAILABLE

	‚úî Messages can change, ‚úî Codes should not

6Ô∏è‚É£ Checked vs unchecked ‚Äî final rule
	Use unchecked (default) when: System/infrastructure failure, Programming or configuration error, Cross-layer propagation needed
	Use checked when: Caller must decide alternative flow, Business workflow continuation is expected
	üìå In large systems: 90% unchecked

7Ô∏è‚É£ What to avoid 
	‚ùå Catching Exception everywhere, One generic ApplicationException for everything, 
	‚ùå Leaking framework exceptions (SQL, HTTP, JSON), Huge inheritance trees, Encoding logic in exception messages

Throwable
 ‚îî‚îÄ‚îÄ RuntimeException
     ‚îî‚îÄ‚îÄ ApplicationException
         ‚îú‚îÄ‚îÄ BusinessException
         ‚îÇ    ‚îú‚îÄ‚îÄ OrderNotFoundException
         ‚îÇ    ‚îú‚îÄ‚îÄ InsufficientBalanceException
         ‚îÇ
         ‚îú‚îÄ‚îÄ ServiceException
         ‚îÇ
         ‚îî‚îÄ‚îÄ InfrastructureException
              ‚îú‚îÄ‚îÄ DatabaseException
              ‚îú‚îÄ‚îÄ ExternalServiceException

===========================================================================================================
üîπ Q13. What is exception chaining? Why is exception chaining important?
===========================================================================================================
‚úÖ Exception chaining is the practice of wrapping one exception inside another so that the original (root) cause is preserved.
	In Java, this is done using the cause.

		catch (SQLException e) {
			throw new ServiceException("Failed to fetch user", e);
		}
		Here: ServiceException = higher-level exception, SQLException = root cause
		The original exception is not lost.
‚úÖ How Java supports exception chaining
	1Ô∏è‚É£ Constructor with cause
	2Ô∏è‚É£ Using initCause()
		ServiceException ex = new ServiceException("Service failed");
		ex.initCause(originalException);
		‚ö†Ô∏è Rarely used today (constructors preferred)
		
‚ùå What happens without exception chaining 
	catch (SQLException e) {
		throw new ServiceException("Database error");
	}
	Problems: Root cause lost, Stack trace misleading, Debugging becomes guesswork

üîë Why exception chaining is important 
	1Ô∏è‚É£ Preserves the root cause
		ServiceException
		 ‚îî‚îÄ‚îÄ SQLException
			  ‚îî‚îÄ‚îÄ SocketTimeoutException
		You can trace the failure all the way down.

	2Ô∏è‚É£ Enables layered exception translation: Without chaining ‚Üí blind failure.
		| Layer   | Exception                 |
		| ------- | ------------------------- |
		| DB      | SQLException              |
		| Repo    | DataAccessException       |
		| Service | OrderServiceException     |
		| API     | 500 Internal Server Error |
	
	3Ô∏è‚É£ Better debugging & observability: Full stack trace, Accurate logs, Faster root cause analysis, Critical in production systems.
	4Ô∏è‚É£ Required for modern tooling: APMs (New Relic, Datadog), Error trackers (Sentry), Log correlation tools, They rely on cause chains.
	5Ô∏è‚É£ Prevents anti-patterns
		‚ùå Catch-and-swallow, Catch-and-throw-new, Silent failures
		Exception chaining fixes all of these.
	

===========================================================================================================
üîπ Q14. Difference between getCause() and initCause().
===========================================================================================================
| Method        | Purpose                                                     |
| ------------- | ----------------------------------------------------------- |
| `getCause()`  | **Retrieves** the underlying cause of an exception          |
| `initCause()` | **Sets** (initializes) the underlying cause of an exception |

getCause(): 
	Returns the cause (Throwable) associated with an exception, Read-only operation
	Key points: Returns null if no cause is set, Does not modify the exception, Used for inspection and debugging

initCause(): Sets the cause of an exception after creation
		Exception ex = new Exception("High-level error");
		ex.initCause(originalException);
		throw ex;

	‚ö†Ô∏è Important rules 
		1Ô∏è‚É£ Can be called only once
			ex.initCause(cause1);
			ex.initCause(cause2); // ‚ùå IllegalStateException

		2Ô∏è‚É£ Cannot override an existing cause: If cause is already set (via constructor), calling initCause() fails.
		3Ô∏è‚É£ Cannot set cause to itself: ex.initCause(ex); // ‚ùå IllegalArgumentException

	Why does initCause() exist? Historical reason: Older exception classes (pre‚ÄìJava 1.4) did not support causes
		initCause() was introduced to retrofit chaining support
			Example:
				class LegacyException extends Exception {
					LegacyException(String msg) {
						super(msg);
					}
				}
			To add cause: LegacyException le = new LegacyException("Legacy failure"); le.initCause(e);

‚úÖ Modern best practice 
	üëâ Prefer constructors that accept a cause
			throw new ServiceException("Failed", e);
		‚úî Cleaner, Safer, Immutable after creation
	Use initCause() only when constructor-based chaining is not possible.

‚ùå Common mistakes 
		Calling initCause() after cause already exists
		Using initCause() instead of constructors in new code
		Forgetting to check getCause() before accessing

===========================================================================================================
üîπ Q15. What happens if cause is not preserved? How does exception chaining help debugging?
===========================================================================================================
If the original cause of an exception is not preserved, the root failure information is lost, leading to misleading stack traces, harder debugging, incorrect recovery decisions, and poor observability in production systems. Exception chaining preserves the full causal chain of failures, enabling faster root cause analysis, accurate monitoring, and meaningful exception translation across layers.

===========================================================================================================
üîπ Q16. What is try-with-resources? Why was it introduced?
===========================================================================================================
‚úÖ Try-with-resources is a Java construct (introduced in Java 7) that automatically closes resources when execution leaves the try block. A resource is any object that implements AutoCloseable (or Closeable). No finally. No manual cleanup.

Solves Problems: Boilerplate code, Easy to forget close(), Exceptions in finally could hide the real exception, Messy, unreadable, error-prone

üéØ Why was try-with-resources introduced? 
	1Ô∏è‚É£ Automatic resource management: Ensures close() is always called, Even if an exception occurs, Even if return is executed
	2Ô∏è‚É£ Fixes exception loss (major reason)
		Before: 	‚ùå Original exception lost

		try {
			throw new RuntimeException("TRY");
		} finally {
			throw new RuntimeException("FINALLY");
		}

	With try-with-resources:

	try (Resource r = new Resource()) {
		throw new RuntimeException("TRY");
	}

	If close() throws: Main exception is preserved, close exception is added as suppressed, Throwable[] suppressed = e.getSuppressed();
	‚úî Debugging-friendly ‚úî No lost root cause

	3Ô∏è‚É£ Cleaner, safer code: Less boilerplate, Fewer bugs, Easier reviews, Encourages correct patterns

‚öôÔ∏è How try-with-resources works internally
		Compiler rewrites it into: try finally with guaranteed close, Resources are closed in reverse order of creation
		
		try (A a = new A(); B b = new B()) {
			...
		}
		Close order: b.close(), a.close()

üìú Rules of try-with-resources 
	1Ô∏è‚É£ Resource must implement AutoCloseable
		class MyResource implements AutoCloseable {
			public void close() { }
		}

	2Ô∏è‚É£ Resource is effectively final
		try (Connection c = getConnection()) {
			// cannot reassign c
		}

	3Ô∏è‚É£ Works with multiple resources
		try (
			FileInputStream in = new FileInputStream("a.txt");
			FileOutputStream out = new FileOutputStream("b.txt")
		) {
			...
		}

	4Ô∏è‚É£ You can still use catch
		try (Resource r = ...) {
			...
		} catch (Exception e) {
			...
		}

‚úÖ What kinds of resources use this?
	Common examples: Files, Streams, JDBC Connections, Statements, ResultSets, Sockets, Locks (custom), Any custom cleanup logic
	
‚úÖ Best practices 
		‚úî Always prefer try-with-resources over finally
		‚úî Don‚Äôt swallow exceptions in close()
		‚úî Let suppressed exceptions do their job
		‚úî Use it for any deterministic cleanup, not just IO

===========================================================================================================
üîπ Q17. How does AutoCloseable differ from Closeable?
===========================================================================================================
	| Aspect           | AutoCloseable                | Closeable                     |
	| ---------------- | ---------------------------- | ----------------------------- |
	| Introduced in    | Java 7                       | Java 5                        |
	| Package          | `java.lang`                  | `java.io`                     |
	| `close()` throws | `Exception`                  | `IOException`                 |
	| Purpose          | General resource cleanup     | I/O-specific cleanup          |
	| Used by          | try-with-resources (primary) | I/O streams, readers, writers |


===========================================================================================================
üîπ Q18. What is suppressed exception? Where are How do you access suppressed exceptions?
===========================================================================================================
‚úÖ A suppressed exception is an exception that occurs during cleanup (like close()) but is not the primary exception,
   so Java attaches it to the main exception instead of overriding it. This prevents the real failure from being lost.

‚úÖWhere do suppressed exceptions occur?
	1Ô∏è‚É£ Try-with-resources (MOST COMMON) ‚≠ê
			try (MyResource r = new MyResource()) {
				throw new RuntimeException("Main failure");
			}
		If: MyResource.close() throws an exception
		üëâ Result: Main exception is thrown, close() exception is suppressed

	2Ô∏è‚É£ Multiple resources in try-with-resources
		try (A a = new A(); B b = new B()) {
			throw new RuntimeException("Failure");
		}
		Close order: b.close() ‚Üí a.close()
		If both throw: First close exception ‚Üí suppressed, Second close exception ‚Üí suppressed
		All attached to the main exception

	3Ô∏è‚É£ Manual suppression (rare but valid)
		catch (Exception e) {
			Exception cleanup = new Exception("Cleanup failed");
			e.addSuppressed(cleanup);
			throw e;
		}
		Used when: You want to keep one primary exception, But still record secondary failures

‚úÖ How do you access suppressed exceptions?
	1Ô∏è‚É£ Using getSuppressed()
		try {
			...
		} catch (Exception e) {
			for (Throwable t : e.getSuppressed()) {
				t.printStackTrace();
			}
		}
		Returns: Throwable[], Empty array if none exist
	
	2Ô∏è‚É£ Automatically printed in stack trace: e.printStackTrace();
		Output: Exception: Main failure, Suppressed: Exception: Close failed
		‚úî Already visible in logs, No extra code needed

üîë Why suppressed exceptions are important: 
		Preserve root cause, Don‚Äôt hide cleanup failures
		Improve debugging accuracy, Essential for try-with-resources correctness

	Without suppressed exceptions: Cleanup bugs are invisible, Debugging becomes misleading

‚úÖ Best practices 
	‚úî Always use try-with-resources
	‚úî Never throw from finally
	‚úî Don‚Äôt ignore suppressed exceptions when debugging
	‚úî Let the JVM manage suppression
	
===========================================================================================================
üîπ Q19. Is exception handling expensive? Is throwing an exception costly?
===========================================================================================================
üîë Short, correct answer: Catching an exception is cheap. Throwing an exception is expensive.
‚úÖ Cheap: try-catch with no exception
		try {
			fastOperation();
		} catch (Exception e) {
			// never triggered
		}

		Almost zero overhead, JIT optimizes it heavily, No object creation
		üìå Using try-catch defensively is fine.

‚ùå Expensive: Throwing an exception
		throw new RuntimeException("fail");
		Why it‚Äôs costly üëá
			1Ô∏è‚É£ Exception object creation: New object allocation, Memory pressure, GC impact
			2Ô∏è‚É£ Stack trace capture (biggest cost):
				JVM walks the entire call stack, Captures method names, line numbers
				new Exception().getStackTrace(); // expensive
				This is the dominant cost.

			3Ô∏è‚É£ Stack unwinding: JVM exits multiple stack frames, Clears execution state
			4Ô∏è‚É£ JIT optimization barriers: Exception-heavy code prevents inlining, Hot paths get slower

‚öôÔ∏è How to reduce exception cost (when needed) 
	1Ô∏è‚É£ Don‚Äôt use exceptions for normal flow
			Use: Return values, Optional, Result objects
	
	2Ô∏è‚É£ Avoid filling stack trace (advanced): new RuntimeException(msg, null, false, false);
		‚úî Faster, ‚ùå No stack trace (use carefully)
	
	3Ô∏è‚É£ Pre-check instead of catching:
			if (file.exists()) {
				...
			}

	4Ô∏è‚É£ Throw exceptions at boundaries, not in loops: Validate early, Fail fast

1Ô∏è‚É£ Exception creation cost (expensive)
	What does ‚Äúcreation‚Äù mean: It includes: new Exception(...), throw exception, Capturing stack trace, Stack unwinding
		throw new RuntimeException("error");
	Why it‚Äôs expensive
		üîπ 1. Object allocation: Heap allocation, GC pressure,
		üîπ 2. Stack trace capture (BIGGEST COST): 
				JVM walks the call stack
				Records method, class, line number
				Cost grows with stack depth
				Throwable.fillInStackTrace(); // expensive
		üîπ 3. Stack unwinding: JVM exits all active stack frames, Clears execution state
		üîπ 4. JIT de-optimization: Hot paths lose inlining, Performance drops in exception-heavy code
	üìå This is why throwing exceptions in loops is disastrous.

2Ô∏è‚É£ Exception handling cost (cheap ‚úÖ)
	What does ‚Äúhandling‚Äù mean: It includes: Entering try-catch, Matching exception type, Executing catch block

		try {
			fast();
		} catch (Exception e) {
			handle(e);
		}

	Why it‚Äôs cheap: No object creation, No stack trace generation, JVM optimizes try-catch aggressively
		Near-zero overhead when no exception occurs

üìå A try-catch around normal code is not slow.

===========================================================================================================
üîπ Q20. What happens internally when an exception is thrown?
===========================================================================================================
‚úÖ Let‚Äôs start with a simple line: throw new RuntimeException("error"); This triggers a multi-step process inside the JVM.
	1Ô∏è‚É£ Exception object creation (heap allocation) : new RuntimeException("error");
		Internally: JVM allocates memory on the heap
		Initializes: exception message, cause (if any), suppressed exceptions list (empty initially)
		At this point, it‚Äôs just a normal object.

	2Ô∏è‚É£ Stack trace capture (most expensive step) :When the exception is created, the JVM calls:
		Throwable.fillInStackTrace()
		What happens here: 
			JVM walks the current thread‚Äôs call stack
			Records: class names, method names, line numbers, Stores this info inside the exception object
		üìå This is the biggest performance cost of throwing exceptions.

	3Ô∏è‚É£ throw instruction executed: When the JVM executes the throw bytecode:
			Normal execution stops immediately
			Current instruction pointer is abandoned
			JVM switches to exception dispatch mode
			No more statements in the current method are executed.

	4Ô∏è‚É£ Stack unwinding begins: The JVM now tries to find a matching catch block.
		Process:
			Look at the current method, Check its exception table (created at compile time)
			Try to find a catch block that
			Matches the exception type (or superclass)
			Covers the current instruction range

	5Ô∏è‚É£ If no matching catch ‚Üí unwind stack : If the current method cannot handle it:
		JVM: Pops the current stack frame, Restores the caller‚Äôs frame, Repeats the same lookup in the caller method
		This continues up the call stack.
		üìå This is why deep stacks make exceptions more expensive.

	6Ô∏è‚É£ Catch block found : Once a matching catch block is found:
		JVM: 
			Pushes the exception object onto the operand stack
			Transfers control to the catch block
			Normal execution resumes inside the catch

			catch (RuntimeException e) {
				// execution resumes here
			}

	7Ô∏è‚É£ If no catch exists anywhere: If the JVM reaches the top of the stack (e.g., main) and finds no handler:
		The thread terminates
		JVM prints: exception message, stack trace, For the main thread ‚Üí JVM exits (unless other non-daemon threads exist)

	8Ô∏è‚É£ What about finally? During stack unwinding:
		JVM executes finally blocks
		This happens: before moving to the next stack frame, even if no catch exists
		Exception: System.exit() : JVM crash

===========================================================================================================
üîπ Q21. Rules for exceptions in method overriding including abstract class, interface.
===========================================================================================================
1Ô∏è‚É£ Core rules for exceptions in method overriding
üîë Golden Rule : An overriding method cannot throw broader checked exceptions than the overridden method.
	This applies to: Classes, Abstract classes, Interfaces

2Ô∏è‚É£ Rules for checked exceptions 
	‚ùå Rule 1: Cannot throw broader checked exception
	‚úÖ Rule 2: Can throw same checked exception
	‚úÖ Rule 3: Can throw narrower checked exception
	‚úÖ Rule 4: Can throw no checked exception

3Ô∏è‚É£ Rules for unchecked exceptions (RuntimeException)
	Unchecked exceptions: Are not part of method signature, Are not enforced by compiler
	‚úî Can be broader, Can be narrower, Can be new ones

üîëOverriding must preserve the contract (LSP)
	Liskov Substitution Principle: A subclass must be substitutable for its superclass.
	For checked exceptions: Caller knows what to handle, Broadening breaks that promise
	For unchecked exceptions: Caller never relied on handling them, No contract is violated

===========================================================================================================
üîπ Q22. Why lambdas cannot throw checked exceptions easily? How do you handle checked exceptions in streams?
===========================================================================================================
1Ô∏è‚É£ Why lambdas cannot throw checked exceptions easily
Core reason: 
	A lambda expression must conform exactly to the exception signature of its target functional interface.
	A lambda is not its own method ‚Äî it‚Äôs an implementation of a functional interface method.

Example problem ‚ùå
	List<String> files = List.of("a.txt", "b.txt");

	files.forEach(f -> {
		Files.readAllLines(Path.of(f)); // throws IOException ‚ùå
	});
	
	Why this fails: 
		forEach expects a Consumer<T>, Consumer.accept() does not declare throws IOException
		Lambda cannot add new checked exceptions

2Ô∏è‚É£ Why Java designed lambdas this way üß†
	üîπ 1. Lambdas are implementations, not declarations
			If lambdas could throw arbitrary checked exceptions:
				APIs like Stream.forEach would become unusable
				Every caller would need massive try-catch blocks
	
	üîπ 2. Backward compatibility
			Streams and functional interfaces were added in Java 8:
				Existing interfaces (Runnable, Consumer, Function) had no checked exceptions
				Java couldn‚Äôt change them without breaking old code

	üîπ 3. Checked exceptions don‚Äôt compose well
			Streams rely on function composition: map ‚Üí filter ‚Üí flatMap ‚Üí collect
			Checked exceptions break this flow: Which stage throws?, Who handles it?, How is it propagated?
			Java chose simplicity over expressiveness here.

3Ô∏è‚É£ How to handle checked exceptions in streams
	‚úÖ Option 1: Handle inside lambda (most common)
			files.forEach(f -> {
				try {
					Files.readAllLines(Path.of(f));
				} catch (IOException e) {
					throw new UncheckedIOException(e);
				}
			});
			‚úî Works, Preserves cause, ‚ùå Less clean

	‚úÖ Option 2: Convert to unchecked exception (recommended)
			files.stream()
				 .map(f -> {
					 try {
						 return Files.readAllLines(Path.of(f));
					 } catch (IOException e) {
						 throw new UncheckedIOException(e);
					 }
				 })
				 .forEach(System.out::println);

			üìå UncheckedIOException exists exactly for this reason.

	‚úÖ Option 3: Extract method that handles exception
			files.stream()
				 .map(this::readSafely)
				 .forEach(System.out::println);

			private List<String> readSafely(String f) {
				try {
					return Files.readAllLines(Path.of(f));
				} catch (IOException e) {
					throw new UncheckedIOException(e);
				}
			}
			‚úî Clean lambda, Good readability, Preferred in real projects

	‚úÖ Option 4: Custom functional interface (advanced)
				@FunctionalInterface
				interface CheckedFunction<T, R> {
					R apply(T t) throws Exception;
				}

			Then wrap it:

				static <T, R> Function<T, R> wrap(CheckedFunction<T, R> f) {
					return t -> {
						try {
							return f.apply(t);
						} catch (Exception e) {
							throw new RuntimeException(e);
						}
					};
				}
			
			Usage:

				files.stream()
					 .map(wrap(this::readFile))
					 .forEach(System.out::println);


			‚úî Powerful, ‚ùå More complex, ‚ùå Usually avoided unless framework-level code

	‚ùå Option to avoid: swallowing exceptions
		catch (IOException e) {
			return null; // ‚ùå very bad
		}
		Leads to: Hidden bugs, NPEs later, Silent data corruption, 

4Ô∏è‚É£ Why streams + checked exceptions feel painful (truth)
	Streams are designed for: Pure transformations, Stateless operations, Functional style
	Checked exceptions represent: I/O, Side effects, External systems
	üëâ That‚Äôs an impedance mismatch, not a bug.

===========================================================================================================
üîπ Q23. How are exceptions handled in threads? What happens if a thread throws unchecked or checked exception?
===========================================================================================================
How are exceptions handled in threads?
üîë Key rule: 
	Exceptions thrown inside a thread do NOT propagate to the thread that started it.
	Each thread has its own call stack and exception lifecycle.

1Ô∏è‚É£ What happens if a thread throws an unchecked exception?
		Example
		Thread t = new Thread(() -> {
			throw new RuntimeException("Boom");
		});
		t.start();
	What happens internally: Exception is not caught inside the thread
		JVM: Prints stack trace to stderr, Terminates only that thread, Other threads continue normally
	üìå The application keeps running unless: It was the main thread Or it was the last non-daemon thread

2Ô∏è‚É£ What happens if a thread throws a checked exception?
	üëâ It cannot escape the run() method.
		Why? public void run() { }
		run() does not declare throws
		Checked exceptions must be caught inside the thread
		‚ùå This does not compile:
				new Thread(() -> {
					throw new IOException(); // ‚ùå compile-time error
				});

		Correct handling
				new Thread(() -> {
					try {
						throw new IOException();
					} catch (IOException e) {
						e.printStackTrace();
					}
				});
		Or wrap:
				catch (IOException e) {
					throw new RuntimeException(e);
				}

3Ô∏è‚É£ Default behavior when exception is uncaught
		If an exception escapes run():
		JVM invokes: Thread.getUncaughtExceptionHandler()
		Default behavior: Print stack trace, Terminate the thread

4Ô∏è‚É£ Using UncaughtExceptionHandler (IMPORTANT): It is a callback mechanism invoked when a thread terminates due to an uncaught exception.
	Per-thread handler
		Thread t = new Thread(() -> {
			throw new RuntimeException("Boom");
		});

		t.setUncaughtExceptionHandler((thread, ex) -> {
			log.error("Thread {} failed", thread.getName(), ex);
		});

	‚úî Centralized error handling, Logging / alerts

	Global default handler
		Thread.setDefaultUncaughtExceptionHandler((t, e) -> {
			log.error("Uncaught in {}", t.getName(), e);
		});

	‚úî Catches all uncaught exceptions across threads

5Ô∏è‚É£ Special case: ExecutorService
	executor.submit(() -> {
		throw new RuntimeException("Boom");
	});	
	| Method      | What happens                               |
	| ----------- | ------------------------------------------ |
	| `execute()` | Exception goes to UncaughtExceptionHandler |
	| `submit()`  | Exception is captured inside `Future`      |

	Future<?> f = executor.submit(task);
	f.get(); // throws ExecutionException
	üìå Very common interview trap.

6Ô∏è‚É£ Main thread exception behavior
	If main thread throws unchecked exception: JVM terminates if no non-daemon threads exist
	Otherwise: Other threads continue
	
	
===========================================================================================================
üîπ Q24. Difference between exception handling in Thread vs ExecutorService.
===========================================================================================================
3Ô∏è‚É£ Exception handling: Thread vs ExecutorService: This is a very common interview trap ‚ö†Ô∏è

Plain Thread
	new Thread(() -> {
		throw new RuntimeException("Boom");
	}).start();

	Exception: Goes to UncaughtExceptionHandler, Thread dies immediately

ExecutorService.execute()
	executor.execute(() -> {
		throw new RuntimeException("Boom");
	});
	Behaves like Thread, Exception: Sent to UncaughtExceptionHandler, Worker thread may be replaced

ExecutorService.submit() ‚ùó (IMPORTANT)
	Future<?> f = executor.submit(() -> {
		throw new RuntimeException("Boom");
	});
	Exception is captured, Thread does NOT crash, Exception is stored inside Future
	f.get(); // throws ExecutionException (wraps original)
	üìå If you never call get() ‚Üí exception is silently ignored
	
	
===========================================================================================================
üîπ Q25. How are exceptions propagated in CompletableFuture? How do you handle exceptions in async pipelines?
===========================================================================================================
4Ô∏è‚É£ How are exceptions propagated in CompletableFuture?
	CompletableFuture uses value-based exception propagation, not thread-based.
			CompletableFuture<Integer> cf =
				CompletableFuture.supplyAsync(() -> {
					throw new RuntimeException("Fail");
				});
	What happens: Exception is stored inside the CompletableFuture, Thread does NOT crash, Future completes exceptionally
	cf.join(); // throws CompletionException
	Root cause: cf.join().getCause();

5Ô∏è‚É£ How do you handle exceptions in async pipelines?
	‚úÖ exceptionally() ‚Äì recover
		cf.exceptionally(ex -> {
			log.error("Failed", ex);
			return -1; // fallback
		});

	‚úÖ handle() ‚Äì inspect success or failure
		cf.handle((result, ex) -> {
			if (ex != null) return -1;
			return result * 2;
		});

	‚úÖ whenComplete() ‚Äì side effects only
		cf.whenComplete((res, ex) -> {
			if (ex != null) log.error("Error", ex);
		});
	üìå whenComplete() does not change outcome
	üìå handle() and exceptionally() can transform result

6Ô∏è‚É£ Why exceptions in threads don‚Äôt crash the JVM?
	Fundamental JVM design principle : Threads are isolated units of execution with independent stacks.
	Reasons
		üîπ 1Ô∏è‚É£ Thread isolation
				Each thread has its own: Call stack, Program counter, Exception unwinds only that stack

		üîπ 2Ô∏è‚É£ JVM is designed for fault tolerance
				Servers run: Thread pools, Background jobs, Async tasks
				One task failing must not kill the process

		üîπ 3Ô∏è‚É£ Only fatal errors can stop the JVM
				Examples: OutOfMemoryError (sometimes)
				JVM crash: System.exit() OS kill Normal exceptions ‚â† fatal JVM state


===========================================================================================================
üîπ Q26. How do you log exceptions correctly in production? How do you handle partial failure?
===========================================================================================================
| Scenario              | Level       |
| --------------------- | ----------- |
| Client input error    | WARN        |
| Business rule failure | INFO / WARN |
| Dependency failure    | ERROR       |
| System bug            | ERROR       |

Structured logging (important)
{
  "level": "ERROR",
  "errorCode": "PAYMENT_TIMEOUT",
  "orderId": 123,
  "traceId": "xyz"
}

7Ô∏è‚É£ How do you handle partial failure?
	Partial failure example: Order placed ‚úî, Payment failed ‚ùå, Inventory reserved ‚úî
	Common strategies
		üîπ 1Ô∏è‚É£ Compensation (Saga pattern)
			Roll back successful steps
			Restore consistency
			Reserve inventory ‚Üí FAIL ‚Üí Release inventory

		üîπ 2Ô∏è‚É£ Graceful degradation: Return partial response, ark failed sections clearly
			{
			  "order": "CREATED",
			  "payment": "FAILED"
			}

		üîπ 3Ô∏è‚É£ Asynchronous recovery: Retry later, Dead-letter queues, Background reconciliation
===========================================================================================================
üîπ Q27. Can static block throw exception? Can we serialize exceptions? Are exceptions immutable?
===========================================================================================================
1Ô∏è‚É£ Rules for exceptions in static blocks
	‚ùå Checked exceptions ‚Äî NOT allowed to escape
	Why: Static blocks cannot declare throws, Checked exceptions must be caught inside
	Correct way:
					static {
						try {
							throw new IOException();
						} catch (IOException e) {
							throw new RuntimeException(e);
						}
					}
	‚úÖ Unchecked exceptions ‚Äî allowed to escape
			class A {
				static {
					throw new RuntimeException("Failure");
				}
			}
		This compiles, but leads to class initialization failure.

2Ô∏è‚É£ What happens at runtime if a static block throws an exception?
		class A {
			static {
				throw new RuntimeException("Boom");
			}
		}
		new A(); 

	üö® Runtime behavior: 
		JVM starts class initialization, Static block throws exception
		JVM wraps it in: ExceptionInInitializerError
		Class fails to load, Any future access to the class fails

3Ô∏è‚É£ Subsequent usage of the class
	A a1 = new A(); // ExceptionInInitializerError
	A a2 = new A(); // NoClassDefFoundError
	why: JVM marks class initialization as failed, Class is now unusable for that ClassLoader

4Ô∏è‚É£ Why does JVM behave this way?
	JVM guarantees: A class must be fully initialized before it can be used.
	If static initialization fails: Class is in an inconsistent state, JVM prevents further usage for safety
	
üîëCan we serialize exceptions? Short answer: Yes. All Java exceptions are serializable by default.
	Why: Throwable implements Serializable, Every exception (Exception, RuntimeException, Error) inherits this
	public class Throwable implements Serializable { ... }

	When you serialize an exception, Java serializes:
		‚úÖ Included: Exception message, Cause (exception chaining), Suppressed exceptions, Stack trace (StackTraceElement[])
		‚ùå Not included (directly): Thread state, Local variables, Execution context beyond stack trace

üîëAre exceptions immutable? Correct answer: Java exceptions are mutable objects
	Why exceptions are not immutable
	1Ô∏è‚É£ Stack trace is mutable
		Throwable t = new RuntimeException("Error");
		t.setStackTrace(new StackTraceElement[0]); // allowed
		‚úî You can replace the stack trace, ‚úî You can clear it, That breaks immutability

	2Ô∏è‚É£ Cause can be set after creation
		Exception e = new Exception("High-level");
		e.initCause(new IOException("Root cause"));
		initCause() mutates the exception
		Allowed once ,	Changes internal state

	3Ô∏è‚É£ Suppressed exceptions can be added: e.addSuppressed(new IllegalStateException("Cleanup failed"));
		Modifies the exception object, Common in try-with-resources

	4Ô∏è‚É£ Stack trace can be re-filled: e.fillInStackTrace();
		Recomputes stack trace, Mutates the object again

	5Ô∏è‚É£ Custom exception fields may be mutable
		class MyException extends RuntimeException {
			List<String> context = new ArrayList<>();
		}
		Unless you design it carefully, it‚Äôs mutable.

===========================================================================================================
üîπ Q28. Can OutOfMemoryError be caught? How JVM handles fatal errors internally?
===========================================================================================================
‚úÖ Yes ‚Äî OutOfMemoryError can be caught, but catching it is usually a very bad idea.
	try {
		allocateHugeMemory();
	} catch (OutOfMemoryError e) {
		System.out.println("OOM caught");
	}

‚úÖ Then why is it usually wrong to catch it? üö®
	1Ô∏è‚É£ OutOfMemoryError means JVM is in a broken state, Heap is exhausted, New objects may not be allocated
		Even logging may fail, Cleanup code may fail
		üëâ The JVM can no longer be trusted to behave correctly
	
	2Ô∏è‚É£ Recovery is unreliable (often impossible): Even this may fail:
			catch (OutOfMemoryError e) {
				log.error("OOM", e); // ‚ùå may itself throw OOM
			}
		Because: Logging allocates memory, Creating new exceptions allocates memory, Building strings allocates memory

	3Ô∏è‚É£ Catching it can hide serious system problems
		If you swallow or ignore it: Application limps along, Data corruption can happen, Latent bugs appear later
		Monitoring may miss the real failure, This violates the fail-fast principle.

‚úÖ What are fatal errors in JVM terms: Fatal errors are conditions where the JVM cannot guarantee correct execution anymore.
	Typical examples: 
		OutOfMemoryError (heap, metaspace, direct memory), StackOverflowError, InternalError, UnknownError
		JVM crashes (SIGSEGV, SIGBUS), Native memory exhaustion
		Class initialization failure (ExceptionInInitializerError in critical paths)
		üìå These are subclasses of Error, not Exception.

üß†High-level JVM philosophy: Threads may fail, but the JVM tries to survive‚Äîunless safety is compromised.
	So the JVM distinguishes between:
		Recoverable failures ‚Üí normal exception handling
		Fatal failures ‚Üí containment or termination
	
‚úÖ What happens internally when a fatal error occurs?
	Let‚Äôs walk through it step by step.
		1Ô∏è‚É£ Error is detected
			The error can originate from: Java heap allocation, Stack growth, Class loading / linking, JIT compilation
			Native (JNI / OS) code
			Example: new byte[Integer.MAX_VALUE];
			JVM detects: Heap allocation failure, GC unable to reclaim enough memory

		2Ô∏è‚É£ JVM tries last-resort recovery (very limited):
			Before giving up, JVM may attempt: Full GC, Clearing soft/weak references, Unloading classes, Reducing compilation activity
			If this fails, JVM proceeds to error signaling.

		3Ô∏è‚É£ Error object creation (best-effort)
			JVM tries to: Allocate an OutOfMemoryError object, Fill minimal stack trace
			‚ö†Ô∏è If memory is extremely low: Stack trace may be incomplete, Error object creation itself may be degraded

		4Ô∏è‚É£ Error is thrown in the current thread
			From JVM‚Äôs perspective: Error is still a Throwable, Normal exception dispatch starts
			So: Stack unwinding begins, catch blocks are searched
				catch (OutOfMemoryError e) { ... } // technically reachable

		5Ô∏è‚É£ Why catching fatal errors usually fails üö®
			Even if caught: Allocating objects may fail, Logging may fail, Locks may be corrupted, Internal JVM invariants may be broken, So recovery logic is unsafe.
			This is why: Catching Error is allowed but discouraged

		6Ô∏è‚É£ Thread-level containment
			In many cases: JVM kills only the failing thread, Other threads may continue
			This is why: One bad request doesn‚Äôt kill a server, Thread pools can replace dead workers, But this is not guaranteed.

		7Ô∏è‚É£ JVM-wide termination (when things are truly fatal)
			JVM will abort the process if: 
				Native code crashes (SIGSEGV), Internal VM invariants break, Memory manager is corrupted, Critical system threads fail
			What happens then: JVM prints fatal error log (hs_err_pid.log), OS terminates the process, No Java-level recovery possible

		8Ô∏è‚É£ Special case: OutOfMemoryError
			OOM is interesting because it‚Äôs sometimes survivable.
			JVM behavior: Throw OOM in allocating thread, Other threads may continue, But future allocations are unreliable
			Common JVM options:
				-XX:+ExitOnOutOfMemoryError
				-XX:+HeapDumpOnOutOfMemoryError
			These instruct JVM to: Dump diagnostics, Exit immediately (recommended for prod)

		9Ô∏è‚É£ Class initialization fatal errors
				class A {
					static {
						throw new RuntimeException();
					}
				}

			JVM behavior: Class initialization fails, JVM marks class as erroneous, Any future use ‚Üí NoClassDefFoundError
			This is classloader-level fatal, not JVM-wide.

		10Ô∏è‚É£ Why JVM doesn‚Äôt always crash immediately
			Design reasons: Server workloads need isolation, One request ‚â† whole process, JVM aims for fault containment
			But: Once JVM correctness is uncertain, it prefers termination over corruption

===========================================================================================================
üîπ Q29. Why checked exceptions are controversial? How exception handling affects API usability?
===========================================================================================================
1Ô∏è‚É£ Why are checked exceptions controversial? Original intent (why Java introduced them)
	Checked exceptions were meant to: Make error handling explicit, Force callers to acknowledge failures, Improve program correctness
		void readFile() throws IOException;
		This forces:
			try {
				readFile();
			} catch (IOException e) {
				// must decide what to do
			}
		Sounds good in theory ‚úîÔ∏è
		But in practice‚Ä¶ üëá

2Ô∏è‚É£ Problems with checked exceptions (why people dislike them)
	üî¥ 1Ô∏è‚É£ They pollute APIs: void process() throws IOException, SQLException, ParseException;
			Callers now: Know internal implementation details, Are tightly coupled to lower layers
			üìå Leaky abstraction

	üî¥ 2Ô∏è‚É£ They don‚Äôt scale in large systems: 
			As code evolves: New failure modes appear, throws clauses grow endlessly, Changing exceptions becomes breaking API change
			// Adding a new checked exception breaks all callers
			void process() throws IOException, TimeoutException;

	üî¥ 3Ô∏è‚É£ Encourage bad practices
			Developers often respond with:
				catch (Exception e) {
					throw new RuntimeException(e);
				}
			Or worse:
				catch (Exception e) { // ignore }
			So the compiler requirement doesn‚Äôt guarantee good handling.

	üî¥ 4Ô∏è‚É£ Poor fit for functional & async code: Lambdas, Streams, CompletableFuture, Reactive programming
			Checked exceptions: Don‚Äôt compose, Don‚Äôt flow naturally through pipelines, 
			That‚Äôs why Java added: UncheckedIOException, CompletionException

	üî¥ 5Ô∏è‚É£ Versioning nightmare for public APIs: 
			Once you expose a checked exception: You can never remove it safely, Clients depend on it, You‚Äôre stuck forever
			This makes API evolution painful.

3Ô∏è‚É£ How exception handling affects API usability
	A. Checked exceptions ‚Äî PROs ‚úÖ
		‚úî Explicit failure contract, Forces caller awareness, Good for business-level recoverable errors
		Example: withdraw(amount) throws InsufficientBalanceException;
		Caller knows: This can happen, Must handle it

	B. Checked exceptions ‚Äî CONs ‚ùå
		‚ùå Verbose code, Tight coupling, Hard to evolve, Poor developer experience
		API usage becomes noisy:
				try {
					service.process();
				} catch (IOException e) {
					throw new RuntimeException(e);
				}

	C. Unchecked exceptions ‚Äî PROs ‚úÖ
		‚úî Clean APIs, Better composability, Easier refactoring, Better for async/functional styles
		That‚Äôs why: Spring, Hibernate, JPA, Netflix OSS üëâ Prefer unchecked exceptions

	D. Unchecked exceptions ‚Äî CONs ‚ùå
		‚ùå Errors can be hidden, Less compiler enforcement, Requires discipline & documentation

4Ô∏è‚É£ Why modern frameworks avoid checked exceptions
	Framework philosophy: ‚ÄúIf the caller cannot meaningfully recover, don‚Äôt force them to catch.‚Äù
	Example: DataAccessException extends RuntimeException Instead of: SQLException
	This: Hides implementation details, Keeps APIs stable, Improves usability

5Ô∏è‚É£ When checked exceptions still make sense üëç
	Checked exceptions are good when: Error is expected, Error is recoverable, Caller can take alternate action
	Examples: Business rule violations, Domain-specific workflows, User-driven errors
	Bad when: Error is technical, Error is unrecoverable, Error crosses many layers

6Ô∏è‚É£ Design guideline (industry-standard) üß†
	| Situation               | Preferred           |
	| ----------------------- | ------------------- |
	| Business rule violation | Checked (sometimes) |
	| Infrastructure failure  | Unchecked           |
	| Framework/library APIs  | Unchecked           |
	| Async / streams         | Unchecked           |
	| Public stable APIs      | Minimal checked     |

===========================================================================================================
üîπ Q30. How do you design exception strategy for large systems? How do you test exception paths?
===========================================================================================================
‚úÖDesigning an exception strategy for large systems
	1Ô∏è‚É£ Define clear exception goals (first principle): Before writing code, decide: 
		What failures are business vs technical, What failures are recoverable vs fatal
		Who is responsible for handling each failure, Exceptions are part of system design, not just error handling.

	2Ô∏è‚É£ Use a layered exception model: Design exceptions around architecture layers.
		API / Controller, Service / Domain, Infrastructure (DB, HTTP, MQ)
		Rule: Lower layers never leak exceptions upward.

		Example hierarchy (recommended)
		RuntimeException
		 ‚îî‚îÄ‚îÄ ApplicationException
			 ‚îú‚îÄ‚îÄ BusinessException
			 ‚îÇ    ‚îú‚îÄ‚îÄ OrderNotFoundException
			 ‚îÇ    ‚îú‚îÄ‚îÄ InsufficientBalanceException
			 ‚îÇ
			 ‚îú‚îÄ‚îÄ ServiceException
			 ‚îÇ
			 ‚îî‚îÄ‚îÄ InfrastructureException
				  ‚îú‚îÄ‚îÄ DatabaseException
				  ‚îú‚îÄ‚îÄ ExternalServiceException


		‚úî Clear ownership, Easy mapping to API responses, Stable contracts

	3Ô∏è‚É£ Prefer unchecked exceptions (with discipline): 
		Why unchecked by default? Cleaner APIs, Better scalability, Better async / stream support, Fewer breaking changes
		When to use checked? Business workflows, Expected, recoverable outcomes
		üìå Rule of thumb: 90% unchecked, 10% checked

	4Ô∏è‚É£ Enforce exception translation at boundaries üîÑ
		Repository layer
				catch (SQLException e) {
					throw new DatabaseException("DB failure", e);
				}

		Service layer
				catch (DatabaseException e) {
					throw new ServiceException("Order processing failed", e);
				}

		API layer
				ServiceException ‚Üí HTTP 500
				BusinessException ‚Üí HTTP 4xx

	5Ô∏è‚É£ Standardize error representation (critical at scale): 
		Define a common error model:
			{
			  "errorCode": "ORDER_NOT_FOUND",
			  "message": "Order does not exist",
			  "traceId": "abc-123"
			}
		‚úî Stable error codes, Localized messages, Observability

	6Ô∏è‚É£ Decide retry vs fail-fast centrally
		Categorize exceptions
		Retryable (timeouts, transient failures)
		Non-retryable (validation, business rules)
		Attach metadata: interface Retryable { } Or: ErrorCode.PAYMENT_TIMEOUT.isRetryable()

	7Ô∏è‚É£ Observability-first exception design üëÄ
		Every exception should support: Error code, Correlation ID, Root cause chain, Structured logging
		If you can‚Äôt observe it, you can‚Äôt fix it.

‚úÖHow do you test exception paths?
	Testing exception paths is where most teams fail.

	1Ô∏è‚É£ Unit test exception behavior (not just throwing)
		‚ùå Bad test: assertThrows(Exception.class, () -> service.process());

		‚úÖ Good test
			OrderNotFoundException ex = assertThrows(OrderNotFoundException.class, () -> service.getOrder(id));
			assertEquals("ORDER_NOT_FOUND", ex.getErrorCode());
			Test: ‚úî Type, Message, Error code, Cause

	2Ô∏è‚É£ Mock failures at boundaries üé≠
		Use mocks to simulate failures.
			when(repo.findById(id)).thenThrow(new SQLException("DB down"));

		Verify translation: assertThrows(DatabaseException.class, ...);

	3Ô∏è‚É£ Test retry vs non-retry behavior
		verify(retryTemplate, times(3)).execute(...); Or: assertDoesNotThrow(() -> service.process());

	4Ô∏è‚É£ Integration tests for API error responses üåê
		Validate: HTTP status, Error body, 	No internal details leaked
			{
			  "errorCode": "INVALID_INPUT",
			  "message": "Invalid request"
			}
		‚ùå Stack traces in response = test failure

	5Ô∏è‚É£ Chaos & fault injection testing ‚ö°
		In large systems: Kill dependencies, Inject latency, Simulate timeouts
		Verify: Graceful degradation, Circuit breakers open, Correct error propagation

	6Ô∏è‚É£ Test logging & observability (often ignored)
		Assert logs contain: traceId, errorCode
		Ensure exceptions logged once

	7Ô∏è‚É£ Negative testing mindset üß†
		Ask: What if DB is down?, What if network times out?, What if dependency returns garbage? What if partial success occurs?
		Design tests around failure modes, not happy paths.

	8Ô∏è‚É£ Avoid common testing mistakes
		‚ùå Only testing happy path, Catching and ignoring exceptions in tests, Over-mocking internal logic
		‚ùå Testing framework exceptions instead of domain ones